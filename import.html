<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Importar GEDCOM</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="app-shell">
      <aside class="sidebar">
        <div class="logo">XPTO</div>
        <nav>
          <a href="index.html">Cadastro</a>
          <a href="indicadores.html">Indicadores</a>
          <a href="pessoas.html">Pessoas</a>
          <a href="import.html" class="active">Importar</a>
          <a href="export.html">Exportar</a>
        </nav>
      </aside>
      <main class="content">
        <div class="topbar">
          <div><h1 style="margin:0;font-size:1.25rem;">Importar GEDCOM</h1></div>
          <div></div>
        </div>

        <div class="card" style="max-width:760px;">
          <p style="color:var(--text-secondary);margin-top:6px;">
            Aqui pode carregar um ficheiro GEDCOM (.ged). A importação irá substituir todos os dados atuais (Pessoas, Eventos e Relações) no armazenamento local. Faça um backup/export antes se quiser preservar os dados atuais.
          </p>

          <div style="display:flex;gap:12px;align-items:center;margin-top:12px;">
            <input type="file" id="gedcomFile" accept=".ged,text/plain" />
            <button class="btn" id="importBtn">Importar GEDCOM</button>
          </div>

          <div id="importLog" style="margin-top:16px;color:var(--text-secondary);font-size:0.95rem;white-space:pre-wrap;"></div>
          <div id="importHistoryContainer" style="margin-top:18px;">
            <h3 style="margin:0 0 8px 0;font-size:1rem;">Histórico de importações (últimos 5)</h3>
            <div id="importHistory" style="color:var(--text-secondary);font-size:0.95rem;"></div>
          </div>
        </div>

      </main>
    </div>

    <script>
      function nowISO(){ return new Date().toISOString(); }
      function showLog(msg){ document.getElementById('importLog').textContent = msg; }

      function getImportHistory(){ try{ return JSON.parse(localStorage.getItem('importHistory:xpto')||'[]'); }catch(e){ return []; } }
      function saveImportHistory(hist){ localStorage.setItem('importHistory:xpto', JSON.stringify(hist)); }
      function renderImportHistory(){
        const container = document.getElementById('importHistory');
        const hist = getImportHistory() || [];
        if(!hist || hist.length===0){ container.innerHTML = '<div style="font-style:italic;color:var(--text-secondary);">Sem importações anteriores.</div>'; return; }

        // ensure sorted by date desc (newest first)
        hist.sort((a,b) => {
          const da = a && a.when ? new Date(a.when).getTime() : 0;
          const db = b && b.when ? new Date(b.when).getTime() : 0;
          return db - da;
        });

        function fmtWhen(iso){
          try{
            const d = new Date(iso);
            const pad = n => String(n).padStart(2,'0');
            return `${pad(d.getDate())}-${pad(d.getMonth()+1)}-${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
          }catch(e){ return iso || ''; }
        }

        let html = '<table style="width:100%;border-collapse:collapse;font-size:0.95rem;"><thead><tr style="text-align:left;color:var(--text-secondary)"><th>Quando</th><th>Ficheiro</th><th>Apagados</th><th>Inseridos</th></tr></thead><tbody>';
        hist.forEach(row => {
          const when = fmtWhen(row.when);
          html += `<tr><td style="padding:6px 8px;border-top:1px solid rgba(0,0,0,0.06);">${when}</td><td style="padding:6px 8px;border-top:1px solid rgba(0,0,0,0.06);">${row.fileName || ''}</td><td style="padding:6px 8px;border-top:1px solid rgba(0,0,0,0.06);">${row.deleted}</td><td style="padding:6px 8px;border-top:1px solid rgba(0,0,0,0.06);">${row.inserted}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }

      // render history on load
      try{ renderImportHistory(); }catch(e){ /* ignore */ }

      document.getElementById('importBtn').addEventListener('click', function(){
        const f = document.getElementById('gedcomFile').files[0];
        if(!f) return alert('Selecione um ficheiro GEDCOM (.ged)');
        if(!confirm('Confirma substituição de TODOS os dados existentes com os do ficheiro GEDCOM?')) return;

        // counts of existing records (to report as "apagados")
        const prevPeople = JSON.parse(localStorage.getItem('people:xpto')||'[]');
        const prevEvents = JSON.parse(localStorage.getItem('events:xpto')||'[]');
        const prevRelations = JSON.parse(localStorage.getItem('relations:xpto')||'[]');
        const deletedCount = (prevPeople.length || 0) + (prevEvents.length || 0) + (prevRelations.length || 0);

        const reader = new FileReader();
        reader.onload = function(e){
          try {
            const txt = e.target.result;
            const {people, events, relations, report} = parseGedcom(txt);
            // write to localStorage (overwrite)
            localStorage.setItem('people:xpto', JSON.stringify(people));
            localStorage.setItem('events:xpto', JSON.stringify(events));
            localStorage.setItem('relations:xpto', JSON.stringify(relations));

            const insertedCount = (people.length || 0) + (events.length || 0) + (relations.length || 0);

            // update import history (keep last 5)
            const hist = getImportHistory();
            hist.unshift({ when: nowISO(), fileName: f.name || '', deleted: deletedCount, inserted: insertedCount });
            const trimmed = hist.slice(0,5);
            saveImportHistory(trimmed);
            renderImportHistory();

            // build human readable summary
            let summary = `Import concluído.\nPessoas importadas: ${people.length}\nEventos importados: ${events.length}\nRelações importadas: ${relations.length}\n\n`;

            if(report.peopleWarnings && report.peopleWarnings.length){
              summary += 'Avisos sobre pessoas importadas:\n';
              report.peopleWarnings.forEach(w => summary += `- ${w.id || '(sem id)'}: ${w.reason}\n`);
              summary += '\n';
            }

            if(report.skippedEvents && report.skippedEvents.length){
              summary += 'Eventos não importados:\n';
              report.skippedEvents.forEach(s => summary += `- ${s.id || '(sem id)'}: ${s.reason}\n`);
              summary += '\n';
            }

            if(report.skippedRelations && report.skippedRelations.length){
              summary += 'Relações não importadas:\n';
              report.skippedRelations.forEach(s => summary += `- ${s.description || s.id || '(sem descrição)'}: ${s.reason}\n`);
              summary += '\n';
            }

            showLog(summary.trim());
          } catch(err){
            console.error(err);
            showLog('Erro ao importar: ' + (err && err.message || err));
          }
        };
        reader.readAsText(f, 'utf-8');
      });

      // Basic GEDCOM parser: extracts INDI (individuals) and FAM (families) and common events (BIRT, DEAT)
      function parseGedcom(text){
        const lines = text.split(/\r?\n/).map(l => l.replace(/\t/g,' ').trimEnd());
        const records = [];
        let cur = null;
        for(const raw of lines){
          if(!raw) continue;
          const m = raw.match(/^(\d+)\s+(.*)$/);
          if(!m) continue;
          const level = parseInt(m[1],10);
          const rest = m[2];
          if(level === 0){
            if(cur) records.push(cur);
            cur = {raw:[rest], lines: [raw]};
          } else if(cur){
            cur.raw.push(rest);
            cur.lines.push(raw);
          }
        }
        if(cur) records.push(cur);

        const individuals = {};
        const families = {};

        for(const r of records){
          const first = r.raw[0];
          // INDIVIDUAL
          const indMatch = first.match(/^@([^@]+)@\s+INDI/);
          if(indMatch){
            const xref = indMatch[1];
            const obj = {id: xref, raw: r.raw.slice()};
            // parse lines inside
            let i=1;
            while(i<r.raw.length){
              const part = r.raw[i];
              if(part.startsWith('NAME')){
                const name = part.replace(/^NAME\s+/,'').trim();
                const surnameMatch = name.match(/\/(.*?)\//);
                obj.lastName = surnameMatch ? surnameMatch[1].trim() : '';
                obj.firstName = name.replace(/\/(.*?)\//,'').trim();
              } else if(part.startsWith('SEX')){
                const sex = part.replace(/^SEX\s+/,'').trim();
                obj.gender = (sex === 'M') ? 'male' : (sex === 'F') ? 'female' : 'other';
              } else if(part.startsWith('BIRT')){
                if(r.raw[i+1] && r.raw[i+1].startsWith('DATE')){
                  obj.birth = r.raw[i+1].replace(/^DATE\s+/,'').trim();
                }
              } else if(part.startsWith('DEAT')){
                if(r.raw[i+1] && r.raw[i+1].startsWith('DATE')){
                  obj.death = r.raw[i+1].replace(/^DATE\s+/,'').trim();
                }
              }
              i++;
            }
            individuals[xref] = obj;
            continue;
          }
          // FAMILY
          const famMatch = first.match(/^@([^@]+)@\s+FAM/);
          if(famMatch){
            const xref = famMatch[1];
            const fam = {id: xref, raw: r.raw.slice(), HUSB: null, WIFE: null, CHIL: []};
            r.raw.forEach(line => {
              if(line.startsWith('HUSB')){
                const m = line.match(/@([^@]+)@/); if(m) fam.HUSB = m[1];
              } else if(line.startsWith('WIFE')){
                const m = line.match(/@([^@]+)@/); if(m) fam.WIFE = m[1];
              } else if(line.startsWith('CHIL')){
                const m = line.match(/@([^@]+)@/); if(m) fam.CHIL.push(m[1]);
              }
            });
            families[xref] = fam;
            continue;
          }
        }

        // Build people array and warnings
        const importedPeople = [];
        const peopleWarnings = [];
        Object.values(individuals).forEach(ind => {
          const person = {
            id: ind.id,
            firstName: ind.firstName || '',
            lastName: ind.lastName || '',
            gender: ind.gender || '',
            notes: '',
            createdAt: nowISO(),
            updatedAt: nowISO(),
            deletedAt: null
          };
          importedPeople.push(person);
          const hasName = (person.firstName && person.firstName.trim()) || (person.lastName && person.lastName.trim());
          if(!hasName){ peopleWarnings.push({ id: person.id, reason: 'Nome ausente' }); }
        });

        // Build events (skip events without date)
        const importedEvents = [];
        const skippedEvents = [];
        Object.values(individuals).forEach(ind => {
          if(ind.birth){
            if(ind.birth.trim()){
              importedEvents.push({ id: ind.id + '_BIRT', personId: ind.id, type: 'BIRTH', date: ind.birth, location: null, notes: '', createdAt: nowISO(), updatedAt: nowISO(), deletedAt: null });
            } else {
              skippedEvents.push({ id: ind.id + '_BIRT', reason: 'Data de nascimento ausente' });
            }
          }
          if(ind.death){
            if(ind.death.trim()){
              importedEvents.push({ id: ind.id + '_DEAT', personId: ind.id, type: 'DEATH', date: ind.death, location: null, notes: '', createdAt: nowISO(), updatedAt: nowISO(), deletedAt: null });
            } else {
              skippedEvents.push({ id: ind.id + '_DEAT', reason: 'Data de óbito ausente' });
            }
          }
        });

        // Build relations from families (skip relations that reference unknown individuals)
        const importedRelations = [];
        const skippedRelations = [];
        Object.values(families).forEach(fam => {
          if(fam.HUSB && fam.WIFE){
            if(individuals[fam.HUSB] && individuals[fam.WIFE]){
              importedRelations.push({ from: fam.HUSB, to: fam.WIFE, type: 'mate' });
              importedRelations.push({ from: fam.WIFE, to: fam.HUSB, type: 'mate' });
            } else {
              skippedRelations.push({ description: `fam ${fam.id} mate`, reason: 'Referência a pessoa desconhecida' });
            }
          }
          fam.CHIL.forEach(ch => {
            if(fam.HUSB){
              if(individuals[ch] && individuals[fam.HUSB]){
                importedRelations.push({ from: ch, to: fam.HUSB, type: 'ancestor' });
              } else {
                skippedRelations.push({ description: `fam ${fam.id} filho->pai ${ch}->${fam.HUSB}`, reason: 'Referência a pessoa desconhecida' });
              }
            }
            if(fam.WIFE){
              if(individuals[ch] && individuals[fam.WIFE]){
                importedRelations.push({ from: ch, to: fam.WIFE, type: 'ancestor' });
              } else {
                skippedRelations.push({ description: `fam ${fam.id} filho->mãe ${ch}->${fam.WIFE}`, reason: 'Referência a pessoa desconhecida' });
              }
            }
            // sibling relations
            fam.CHIL.forEach(sib => {
              if(sib !== ch){
                if(individuals[sib] && individuals[ch]){
                  importedRelations.push({ from: ch, to: sib, type: 'siblin' });
                } else {
                  skippedRelations.push({ description: `fam ${fam.id} irmão ${ch}->${sib}`, reason: 'Referência a pessoa desconhecida' });
                }
              }
            });
          });
        });

        const report = {
          peopleWarnings,
          skippedEvents,
          skippedRelations
        };

        return { people: importedPeople, events: importedEvents, relations: importedRelations, report };
      }
    </script>
  </body>
</html>
