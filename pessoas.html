<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pessoas — Gráfico</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css">
    <!-- Cytoscape and dagre for hierarchical layout -->
    <script src="https://unpkg.com/cytoscape@3.24.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.3.2/cytoscape-dagre.js"></script>
    <style>
      /* small adjustments for Cytoscape container and node labels */
      #cy { background: #fafafa; border-radius:8px; }
      .cy-node-label { font-size:12px; font-weight:600; color:#222; }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <aside class="sidebar">
        <div class="logo"><i class="mdi mdi-tree" aria-hidden="true"></i><span>myLineage</span></div>
        <nav>
          <a href="index.html"><i class="mdi mdi-account-multiple" aria-hidden="true"></i>Cadastro</a>
          <a href="indicadores.html"><i class="mdi mdi-chart-bar" aria-hidden="true"></i>Indicadores</a>
          <a href="pessoas.html" class="active"><i class="mdi mdi-account" aria-hidden="true"></i>Pessoas</a>
          <a href="arvore.html"><i class="mdi mdi-sitemap" aria-hidden="true"></i>Árvore</a>
          <a href="import.html"><i class="mdi mdi-file-import" aria-hidden="true"></i>Importar</a>
          <a href="export.html"><i class="mdi mdi-file-export" aria-hidden="true"></i>Exportar</a>
        </nav>
        <div class="sidebar-footer">
          <a href="configuracao.html"><i class="mdi mdi-cog" aria-hidden="true"></i>Definições</a>
        </div>
      </aside>
      <main class="content">
        <div class="topbar">
          <div><h1 style="margin:0;font-size:1.25rem;">Visualização gráfica de Pessoas</h1></div>
          <div>
            <button id="toggleLayoutControls" class="btn lc-toggle" aria-pressed="false" aria-controls="layout-controls">Layout</button>
            <button id="resetFocusBtn" class="btn lc-toggle" title="Resetar pessoa em foco para a definida nas configurações">Reset foco</button>
          </div>
        </div>

        <div class="card">
          <div id="cy" style="width:100%;height:620px;"></div>
          <div class="legend" style="margin-top:12px;">
            <div><span class="avatar" style="background:#4a90e2"></span> Masculino</div>
            <div><span class="avatar" style="background:#e26aa6"></span> Feminino</div>
            <div><span class="avatar" style="background:#9aa0a6"></span> Outro</div>
          </div>
        </div>

        <div id="person-focus" class="person-focus" aria-live="polite"></div>

        <div id="layout-controls" class="layout-controls" aria-hidden="false">
          <div class="lc-header">Layout controls</div>
          <div class="lc-row"><label>Rank direction</label>
            <select id="rankDir"><option value="TB">Top &rarr; Down</option><option value="LR">Left &rarr; Right</option></select>
          </div>
          <div class="lc-row buttons"><button id="resetLayout" class="btn">Reset</button></div>
        </div>

      </main>
    </div>

    <script>
      // Helpers (localStorage-backed data)
      function getPeople(){ try{ const raw = localStorage.getItem('people:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function getPhotos(){ try{ const raw = localStorage.getItem('photos:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function getPhotoRelations(){ try{ const raw = localStorage.getItem('photoRelations:myLineage'); return raw ? JSON.parse(raw) : {}; }catch(e){ return {}; } }
      function genderPlaceholder(g){ const gender = (g||'').toString().toLowerCase(); const color = (gender==='female' || gender==='feminino' || gender==='f') ? '#e26aa6' : (gender==='male' || gender==='masculino' || gender==='m') ? '#4a90e2' : '#9aa0a6'; const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 120 120'><rect width='100%' height='100%' fill='${color}' rx='12'/></svg>`; return 'data:image/svg+xml;base64,' + btoa(svg); }
      function getThumbnailForPerson(personId){ try{ const rels = getPhotoRelations(); const photos = getPhotos(); const ids = rels[personId] || []; if(Array.isArray(ids) && ids.length){ for(const id of ids){ const ph = photos.find(p=>String(p.id)===String(id)); if(ph){ return ph.originalDataUrl || ph.dataUrl || null; } } } return null; }catch(e){ return null; } }

      // ensure RuntimeFocus exists on window for compatibility
      window.RuntimeFocus = window.RuntimeFocus || null;

      // Build a focused subgraph: focused person -> ancestors (upwards), siblings, partner(s), children
      function buildGraphData(){
        const people = getPeople().filter(p=>!p.deletedAt);
        const idMap = new Map(people.map(p=>[String(p.id), p]));
        // determine focus id: RuntimeFocus if set, otherwise persisted focus, otherwise first person
        function getFocusId(){
          if(window.RuntimeFocus && window.RuntimeFocus.id) return String(window.RuntimeFocus.id);
          try{
            const saved = JSON.parse(localStorage.getItem('focusedPerson:myLineage') || 'null');
            if(saved){ if(saved.id) return String(saved.id); if(saved.name){ const name = (saved.name||'').trim().toLowerCase(); const found = people.find(p => (((p.firstName||'') + ' ' + (p.lastName||'')).trim().toLowerCase() === name) || ((p.fullName||'') .toLowerCase() === name) || ((p.name||'').toLowerCase() === name)); if(found) return String(found.id); } }
          }catch(e){}
          return people.length ? String(people[0].id) : null;
        }

        const focusId = getFocusId(); if(!focusId) return { nodes: [], edges: [] };

        const nodesMap = new Map(); const edges = [];
        const parentMap = new Map(); // id -> [fatherId, motherId] (may include nulls)
        function addNode(p){ const id = String(p.id); if(!nodesMap.has(id)) nodesMap.set(id, { data: { id, name: (((p.firstName||'') + ' ' + (p.lastName||'')).trim()) || (p.name||''), img: getThumbnailForPerson(p.id) || genderPlaceholder(p.gender), gender: p.gender || '' } }); }

        // helper: collect parent ids from different possible keys used in data
        function getParentIds(person){ if(!person) return []; const fatherCandidates = [person.fatherId, person.father, person.paiId]; const motherCandidates = [person.motherId, person.mother, person.maeId]; const father = fatherCandidates.find(x=>x!==undefined && x!==null); const mother = motherCandidates.find(x=>x!==undefined && x!==null); const list = []; if(father !== undefined && father !== null) list.push(String(father)); if(mother !== undefined && mother !== null) list.push(String(mother)); // preserve order: father then mother when available
          if(Array.isArray(person.parents)){
            // try to fill missing slots from generic parents array (best-effort)
            const extras = person.parents.filter(x => x!==undefined && x!==null).map(String);
            extras.forEach(x=>{ if(!list.includes(x)) list.push(x); });
          }
          // also check relations store for parent relations (fallback)
          try{
            const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]');
            rels.forEach(r => {
              if(!r) return;
              const from = r.from || r.personId || r.source || r.a || null;
              const to = r.to || r.targetId || r.target || r.b || null;
              const t = (r.type||'').toString().toLowerCase();
              // detect parent-like relation types
              if(!t) return;
              const isParentType = t.includes('parent') || t.includes('pai') || t.includes('mae') || t.includes('mother') || t.includes('father');
              if(!isParentType) return;
              try{
                if(String(from) === String(person.id) && to !== undefined && to !== null){ if(!list.includes(String(to))) list.push(String(to)); }
                else if(String(to) === String(person.id) && from !== undefined && from !== null){ if(!list.includes(String(from))) list.push(String(from)); }
              }catch(e){}
            });
          }catch(e){}
          // try to order as father then mother when possible using known genders
          if(list.length > 1){ const males = []; const females = []; const others = []; list.forEach(id => { const p = idMap.get(String(id)); const g = (p && p.gender) ? p.gender.toString().toLowerCase() : ''; if(g.startsWith('m')) males.push(id); else if(g.startsWith('f')) females.push(id); else others.push(id); }); const ordered = []; if(males.length) males.forEach(x=>{ if(!ordered.includes(x)) ordered.push(x); }); if(females.length) females.forEach(x=>{ if(!ordered.includes(x)) ordered.push(x); }); others.forEach(x=>{ if(!ordered.includes(x)) ordered.push(x); }); return ordered; }
          return list;
        }

        // helper: check nested structures for presence of id (robust fallback)
        function containsId(value, id, seen){ if(value == null) return false; if(seen === undefined) seen = new Set(); if(typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return String(value) === String(id); if(Array.isArray(value)) return value.some(v => containsId(v, id, seen)); if(typeof value === 'object'){ if(seen.has(value)) return false; seen.add(value); return Object.values(value).some(v => containsId(v, id, seen)); } return false; }

        // add root
        const root = idMap.get(focusId);
        if(!root) return { nodes: [], edges: [] };
        addNode(root);

        // ancestors: use same algorithm as arvore.html — consult relations:myLineage (types like 'ancestor'/'child')
        function addAncestors(person){ if(!person) return;
          // collect possible relations from relations store
          const targets = [];
          try{
            const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]');
            function normalizeType(t){ if(!t) return ''; return (''+t).toLowerCase(); }
            function invertType(t){ const n = normalizeType(t); if(n === 'ancestor') return 'child'; if(n === 'child') return 'ancestor'; return n; }
            const relsFrom = rels.filter(r => String(r.from) === String(person.id));
            const relsTo = rels.filter(r => String(r.to) === String(person.id));
            relsFrom.forEach(r => { if(r && (r.to !== undefined && r.to !== null)) targets.push({ id: r.to, type: normalizeType(r.type) }); });
            relsTo.forEach(r => { if(r && (r.from !== undefined && r.from !== null)) targets.push({ id: r.from, type: invertType(r.type) }); });
          }catch(e){}

          // also include explicit parent fields from the person record as 'ancestor'
          try{ const explicit = getParentIds(person); explicit.forEach(pid => { if(pid) targets.push({ id: pid, type: 'ancestor' }); }); }catch(e){}

          // unique by id, prefer explicit ancestor type when present
          const uniqueMap = new Map();
          targets.forEach(t => { if(!t || t.id === undefined || t.id === null) return; const key = String(t.id); const prev = uniqueMap.get(key); if(!prev) uniqueMap.set(key, t); else { // prefer ancestor type
              if((prev.type || '') !== 'ancestor' && (t.type || '') === 'ancestor') uniqueMap.set(key, t);
          } });
          const unique = Array.from(uniqueMap.values());
          // parents are those classified as 'ancestor'
          const parents = unique.filter(u => ((u.type||'') + '').toLowerCase() === 'ancestor').map(u => String(u.id));
          // fallback: if none found, use previous heuristic
          const finalParents = parents.length ? parents : getParentIds(person);

          parentMap.set(String(person.id), finalParents.slice());
          finalParents.forEach(pid=>{ if(!pid) return; const parent = idMap.get(String(pid)); if(parent){ addNode(parent); const g = (parent.gender||'').toString().toLowerCase(); const label = g.startsWith('f') ? 'Mãe' : g.startsWith('m') ? 'Pai' : 'Pai / Mãe'; const edgeId = `e_${String(pid)}_${person.id}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: String(pid), target: String(person.id), label } }); addAncestors(parent); } }); }
        addAncestors(root);
        // fallback: if some parents are referenced in nested fields of root, pick them as well
        try{
          people.forEach(p=>{ if(!p || String(p.id) === String(root.id)) return; if(containsId(root, p.id) && !nodesMap.has(String(p.id))){ addNode(p); const g=(p.gender||'').toString().toLowerCase(); const label = g.startsWith('f') ? 'Mãe' : g.startsWith('m') ? 'Pai' : 'Pai / Mãe'; const edgeId = `e_${String(p.id)}_${root.id}`; if(!edges.find(e=>e.data && e.data.id===edgeId)) edges.push({ data:{ id: edgeId, source: String(p.id), target: String(root.id), label } }); addAncestors(p); } });
        }catch(e){}

        // siblings: people sharing any parent id with root (using all parent keys)
        function addSiblings(person){ if(!person) return; const myParents = new Set(getParentIds(person)); people.forEach(p=>{ const pid = String(p.id); if(pid === String(person.id)) return; const theirParents = getParentIds(p); const shares = theirParents.some(x => myParents.has(String(x))); if(shares){ addNode(p); const g = (p.gender||'').toString().toLowerCase(); const sibLabel = (g==='female' || g==='feminino' || g==='f') ? 'Irmã' : (g==='male' || g==='masculino' || g==='m') ? 'Irmão' : 'Irmão / Irmã'; const edgeId = `e_sib_${person.id}_${pid}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: String(person.id), target: pid, label: sibLabel } }); } }); }
        addSiblings(root);

        // partner(s): check spouseId / partnerId and relations store
        function addPartners(person){ if(!person) return; const partners = new Set(); if(person.spouseId) partners.add(String(person.spouseId)); if(person.partnerId) partners.add(String(person.partnerId)); // scan relations store for mate-like relations
          try{ const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]'); rels.forEach(r=>{ if(!r) return; const from = String(r.from||r.personId||''); const to = String(r.to||r.targetId||''); const t = (r.type||'').toString().toLowerCase(); if((from === String(person.id) && (t.includes('mate')||t.includes('spouse')||t.includes('compan')||t.includes('parceiro')||t.includes('conjuge'))) && to) partners.add(to); if((to === String(person.id) && (t.includes('mate')||t.includes('spouse')||t.includes('compan')||t.includes('parceiro')||t.includes('conjuge'))) && from) partners.add(from); }); }catch(e){}
          partners.forEach(pid=>{ const p = idMap.get(pid); if(p){ addNode(p); const g = (p.gender||'').toString().toLowerCase(); const label = (g==='female'||g==='feminino'||g==='f') ? 'Companheira' : (g==='male'||g==='masculino'||g==='m') ? 'Companheiro' : 'Companheiro(a)'; edges.push({ data: { id: `e_partner_${person.id}_${pid}`, source: String(person.id), target: pid, label, rel: 'partner' } }); } }); }
        addPartners(root);

        // children: people where root is listed as a parent in any supported key
        function addChildren(person){ if(!person) return; const rootId = String(person.id); people.forEach(p=>{ const pid = String(p.id); const parentIds = getParentIds(p); if(parentIds.includes(rootId) || containsId(p, rootId)){ addNode(p); const g=(p.gender||'').toString().toLowerCase(); const label = (g==='female'||g==='feminino'||g==='f') ? 'Filha' : (g==='male'||g==='masculino'||g==='m') ? 'Filho' : 'Filho(a)'; const edgeId = `e_child_${person.id}_${pid}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: rootId, target: pid, label } }); } }); }
        addChildren(root);

        // Build positions for an ancestor-oriented layout (parents above). We'll compute a simple horizontal packing
        // preserve father then mother order using parentMap. We'll produce positions later in renderGraph via preset layout.

        // produce arrays
        const nodes = Array.from(nodesMap.values());
        return { nodes, edges, parentMap, rootId: String(root.id) };
      }

      // Render with Cytoscape using preset positions computed from ancestor tree
      let _cy = null;
      function renderGraph(){
        const data = buildGraphData();
        const container = document.getElementById('cy');
        container.innerHTML = '';
        if(_cy){ try{ _cy.destroy(); }catch(e){} _cy = null; }

        // compute tree positions
        const nodeWidth = 180; const nodeHeight = 140; const hGap = 40; const vGap = 160;
        const parentMap = data.parentMap || new Map();
        const positions = new Map();
        const widths = new Map();
        const visited = new Set();

        function measure(id){ if(widths.has(id)) return widths.get(id); if(visited.has(id)){ widths.set(id, nodeWidth); return nodeWidth; } visited.add(id); const parents = parentMap.get(String(id)) || []; if(!parents || parents.length===0){ widths.set(id, nodeWidth); return nodeWidth; } let sum = 0; parents.forEach(pid=>{ if(!pid) return; if(!idMapHas(pid)) return; sum += measure(pid); }); if(sum === 0) sum = nodeWidth; widths.set(id, sum); return sum; }

        // helper to know if id exists in nodes
        const nodeIds = new Set((data.nodes||[]).map(n=>String(n.data.id)));
        function idMapHas(id){ return nodeIds.has(String(id)); }

        // measure all starting from root
        const rootId = data.rootId;
        if(rootId){ measure(rootId); }

        // compute depth (generation) where root is depth 0, parents depth 1, etc.
        const depthMemo = new Map();
        function getDepth(id){ if(depthMemo.has(id)) return depthMemo.get(id); const parents = parentMap.get(String(id)) || []; if(!parents || parents.length===0){ depthMemo.set(id, 0); return 0; } const d = 1 + Math.max(...parents.map(pid=> idMapHas(pid) ? getDepth(pid) : 0)); depthMemo.set(id, d); return d; }

        // place parents recursively and set positions
        function placeWithY(id, xStart){ const parents = parentMap.get(String(id)) || []; if(!parents || parents.length===0){ const w = widths.get(id) || nodeWidth; const x = xStart + w/2; const y = (getDepth(id) * vGap) * -1; positions.set(String(id), { x, y }); return { left: xStart, right: xStart + w }; }
          let curr = xStart; const centers = []; parents.forEach(pid=>{ if(!idMapHas(pid)) return; const pw = widths.get(pid) || nodeWidth; const r = placeWithY(pid, curr); const center = (r.left + r.right)/2; centers.push(center); curr = r.right + hGap; }); const myX = centers.length ? centers.reduce((a,b)=>a+b,0)/centers.length : xStart + (widths.get(id)||nodeWidth)/2; const y = (getDepth(id) * vGap) * -1; positions.set(String(id), { x: myX, y }); return { left: (centers.length ? Math.min(...centers) - (nodeWidth/2) : xStart), right: (centers.length ? Math.max(...centers) + (nodeWidth/2) : xStart + (widths.get(id)||nodeWidth)) } }

        if(rootId){ const total = widths.get(rootId) || nodeWidth; const startX = - (total/2); placeWithY(rootId, startX); }

        // translate positions into node positions and default y for root if missing
        const positionedNodes = (data.nodes||[]).map(n=>{ const id = String(n.data.id); const pos = positions.get(id) || { x: 0, y: 0 }; return { data: n.data, position: { x: Math.round(pos.x), y: Math.round(pos.y) } }; });

        // ensure edge labels are visible
        const cyElements = { nodes: positionedNodes, edges: data.edges };

        _cy = cytoscape({
          container: container,
          elements: cyElements,
          style: [
            { selector: 'node', style: {
              'shape':'round-rectangle', 'width': nodeWidth, 'height': nodeHeight, 'background-fit':'cover', 'background-image':'data(img)', 'border-width':3,
              'label':'data(name)', 'text-valign':'bottom','text-wrap':'wrap','text-max-width':nodeWidth - 20,'font-size':12,'color':'#222','text-margin-y':6
            }},
            { selector: 'node[gender]', style: { 'border-color': function(ele){ const g = (ele.data('gender')||'').toString().toLowerCase(); return (g==='female'||g==='feminino'||g==='f') ? '#e26aa6' : (g==='male'||g==='masculino'||g==='m') ? '#4a90e2' : '#9aa0a6'; } }},
            { selector: 'edge', style: { 'width':2,'line-color':'#888','target-arrow-shape':'triangle','target-arrow-color':'#888','curve-style':'bezier','label':'data(label)','font-size':11,'text-rotation':'autorotate','text-margin-y':-6,'color':'#333' } },
            { selector: 'edge[rel = "partner"]', style: { 'line-style':'dashed','target-arrow-shape':'none','source-arrow-shape':'none' } }
          ],
          layout: { name: 'preset' }
        });

        _cy.on('tap', 'node', function(evt){ const id = evt.target.id(); window.location.href = `pessoa-detalhe.html?id=${encodeURIComponent(id)}`; });
        _cy.fit(40);
      }

      document.addEventListener('DOMContentLoaded', function(){
        renderGraph();
        // re-render on storage changes
        window.addEventListener('storage', function(){ try{ renderGraph(); }catch(e){} });
        // allow changing rank direction
        const rankSel = document.getElementById('rankDir'); if(rankSel) rankSel.addEventListener('change', ()=>renderGraph());
        // reset focus button
        const resetBtn = document.getElementById('resetFocusBtn'); if(resetBtn) resetBtn.addEventListener('click', ()=>{ location.reload(); });
      });
    </script>
  </body>
</html>
