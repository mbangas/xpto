<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pessoas — Gráfico</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="app-shell">
      <aside class="sidebar">
        <div class="logo">XPTO</div>
        <nav>
          <a href="index.html">Cadastro</a>
          <a href="indicadores.html">Indicadores</a>
          <a href="pessoas.html" class="active">Pessoas</a>
          <a href="import.html">Importar</a>
          <a href="export.html">Exportar</a>
        </nav>
        <div class="sidebar-footer">
          <a href="configuracao.html">Configuração</a>
        </div>
      </aside>
      <main class="content">
        <div class="topbar">
          <div><h1 style="margin:0;font-size:1.25rem;">Visualização gráfica de Pessoas</h1></div>
          <div>
            <button id="toggleLayoutControls" class="btn lc-toggle" aria-pressed="false" aria-controls="layout-controls">Layout</button>
          </div>
        </div>
        <div class="card">
          <svg id="graph" viewBox="0 0 1000 520" preserveAspectRatio="xMidYMid meet"></svg>
          <div class="legend" style="margin-top:12px;">
            <div><span class="avatar" style="background:#4a90e2"></span> Masculino</div>
            <div><span class="avatar" style="background:#e26aa6"></span> Feminino</div>
            <div><span class="avatar" style="background:#9aa0a6"></span> Outro</div>
          </div>
        </div>
        <div id="person-focus" class="person-focus" aria-live="polite"></div>
        <div id="layout-controls" class="layout-controls" aria-hidden="false">
          <div class="lc-header">Layout controls</div>
          <div class="lc-row"><label>Parent spacing</label><input type="range" id="parentSpacingBase" min="100" max="320" step="10"><span id="parentSpacingBaseVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Parent vertical per</label><input type="range" id="parentDyPer" min="10" max="60" step="2"><span id="parentDyPerVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Child spacing</label><input type="range" id="childSpacingBase" min="100" max="320" step="10"><span id="childSpacingBaseVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Child vertical per</label><input type="range" id="childDyPer" min="10" max="60" step="2"><span id="childDyPerVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Sibling radius base</label><input type="range" id="siblingRadiusBase" min="60" max="220" step="5"><span id="siblingRadiusBaseVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Sibling radius per</label><input type="range" id="siblingRadiusPer" min="8" max="80" step="2"><span id="siblingRadiusPerVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Other column gap</label><input type="range" id="otherColGap" min="40" max="400" step="5"><span id="otherColGapVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Other column base</label><input type="range" id="otherColBase" min="0" max="600" step="5"><span id="otherColBaseVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Other row gap</label><input type="range" id="otherRowGap" min="20" max="240" step="2"><span id="otherRowGapVal" class="lc-val"></span></div>
          <div class="lc-row buttons"><button id="resetLayout" class="btn">Reset</button></div>
        </div>
      </main>
    </div>
    <script>
      function getPeople() {
        try { const raw = localStorage.getItem('people:xpto'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; }
      }

      // connect layout-controls sliders to LayoutSettings
      function wireLayoutControls(){
        try{
          const map = {
            parentSpacingBase: 'parentSpacingBase', parentDyPer: 'parentDyPer',
            childSpacingBase: 'childSpacingBase', childDyPer: 'childDyPer',
            siblingRadiusBase: 'siblingRadiusBase', siblingRadiusPer: 'siblingRadiusPer',
            otherColGap: 'otherColGap', otherRowGap: 'otherRowGap', otherColBase: 'otherColBase'
          };
          Object.keys(map).forEach(id => {
            const el = document.getElementById(id);
            if(!el) return;
            // set initial value from LayoutSettings
            el.value = LayoutSettings[map[id]] || el.min || 0;
            // update numeric display
            const valEl = document.getElementById(id + 'Val'); if(valEl) valEl.textContent = el.value;
            el.addEventListener('input', function(){
              LayoutSettings[map[id]] = Number(this.value);
              saveLayoutSettings(LayoutSettings);
              const vEl = document.getElementById(id + 'Val'); if(vEl) vEl.textContent = this.value;
              // re-render graph to apply changes (keeps focus)
              try{ renderGraph(); } catch(e){}
            });
          });
          const reset = document.getElementById('resetLayout');
          if(reset) reset.addEventListener('click', function(){
            // reset to defaults
            LayoutSettings = loadLayoutSettings();
            Object.assign(LayoutSettings, DEFAULT_LayoutSettings);
            saveLayoutSettings(LayoutSettings);
            // update sliders
            Object.keys(map).forEach(id => { const el = document.getElementById(id); if(el) el.value = LayoutSettings[map[id]]; const vEl = document.getElementById(id + 'Val'); if(vEl) vEl.textContent = el.value; });
            renderGraph();
          });
        }catch(e){ console.warn('Layout controls wiring failed', e); }
      }
      function getEvents() {
        try { const raw = localStorage.getItem('events:xpto'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; }
      }
      function formatDate(d){ if(!d) return ''; const t=new Date(d); if(isNaN(t)) return d; return t.getDate().toString().padStart(2,'0') + '-' + (t.getMonth()+1).toString().padStart(2,'0') + '-' + t.getFullYear(); }
      function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

      // Runtime layout settings (editable by UI sliders). Persisted in localStorage under 'layoutSettings:xpto'
      const DEFAULT_LayoutSettings = {
        parentSpacingBase: 200, parentSpacingDecay: 10, parentSpacingMin: 90,
        parentDyBase: 120, parentDyPer: 30, parentDyMax: 360,
        childSpacingBase: 200, childSpacingDecay: 10, childSpacingMin: 90,
        childDyBase: 120, childDyPer: 30, childDyMax: 360,
        siblingRadiusBase: 110, siblingRadiusPer: 36, siblingRadiusMin: 140, siblingRadiusMax: 520,
        otherColGap: 140, otherRowGap: 80, otherColBase: 200
      };

      const LAYOUT_KEY = 'layoutSettings:xpto';
      function loadLayoutSettings(){
        try{ const raw = localStorage.getItem(LAYOUT_KEY); if(!raw) return {...DEFAULT_LayoutSettings}; const obj = JSON.parse(raw); return Object.assign({}, DEFAULT_LayoutSettings, obj); }catch(e){ return {...DEFAULT_LayoutSettings}; }
      }
      function saveLayoutSettings(obj){ try{ localStorage.setItem(LAYOUT_KEY, JSON.stringify(obj)); }catch(e){}
      }
      let LayoutSettings = loadLayoutSettings();

      // Render only Miguel and direct relations in a simple family-tree layout
      function renderGraph(){
        const all = getPeople().filter(p => !p.deletedAt);
        const svg = document.getElementById('graph');
        svg.innerHTML = '';
        if(all.length === 0){
          const msg = document.createElementNS('http://www.w3.org/2000/svg','text');
          msg.setAttribute('x','50%'); msg.setAttribute('y','50%'); msg.setAttribute('text-anchor','middle'); msg.setAttribute('fill','#888'); msg.setAttribute('font-size','18'); msg.textContent = 'Nenhuma pessoa cadastrada.';
          svg.appendChild(msg); return;
        }

        // pick root person: prefer configured focused person (by id or name), else first person
        function fullname(p){ return ((p.firstName||'') + ' ' + (p.lastName||'')).replace(/\s+/g,' ').trim(); }
        let root = null;
        try{
          const FOCUS_KEY = 'focusedPerson:xpto';
          const saved = JSON.parse(localStorage.getItem(FOCUS_KEY) || 'null');
          if(saved){
            if(saved.id !== undefined && saved.id !== null){
              root = all.find(p => String(p.id) === String(saved.id));
            }
            if(!root && saved.name){
              const targetName = (saved.name || '').trim().toLowerCase();
              root = all.find(p => fullname(p).toLowerCase() === targetName || ((p.fullName||'').toLowerCase() === targetName) || ((p.name||'').toLowerCase() === targetName));
            }
          }
        }catch(e){ /* ignore */ }
        if(!root) root = all[0];

        // helper: render person card into the central container
        function renderPersonCard(person){
          const focusEl = document.getElementById('person-focus');
          if(!person){ focusEl.innerHTML = ''; return; }
          const evs = getEvents().filter(ev=>ev.personId === person.id && !ev.deletedAt);
          const birth = evs.find(e=>e.type === 'BIRTH');
          const death = evs.find(e=>e.type === 'DEATH');
          const fullName = ((person.firstName||'') + ' ' + (person.lastName||'')).trim();
          const shortName = fullName.length > 36 ? fullName.slice(0,33) + '…' : fullName;
          focusEl.innerHTML = `
            <div class="person-card" role="article" aria-label="Pessoa em foco">
              <div class="person-name" title="${fullName}">${shortName}</div>
              <div class="person-dates" aria-hidden="false">
                <div class="person-date person-birth">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" stroke="currentColor" stroke-width="1.5"/><path d="M16 2V6M8 2V6M3 10H21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
                  <div class="date-text">${birth && birth.date ? formatDate(birth.date) : ''}</div>
                </div>
                <div class="person-date person-death">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 2v7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M7 11c0 3 2 5 5 5s5-2 5-5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M5 20h14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
                  <div class="date-text">${death && death.date ? formatDate(death.date) : ''}</div>
                </div>
              </div>
            </div>
            <div class="relations-container" aria-hidden="false"></div>
          `;

          // persist focused person (id + name) so re-renders keep the same focus
          try{
            const FOCUS_KEY = 'focusedPerson:xpto';
            localStorage.setItem(FOCUS_KEY, JSON.stringify({ id: person.id, name: fullName }));
          }catch(e){ /* ignore */ }

          // render related person cards around the focus card using relations stored in localStorage ('relations:xpto')
          const relWrap = focusEl.querySelector('.relations-container');
          // use runtime LayoutSettings (modifiable via UI)
          const layout = LayoutSettings;
          function placeCard(el, dx, dy){ el.dataset.x = dx; el.dataset.y = dy; el.style.transform = `translate(${dx}px, ${dy}px)`; }

          // collision resolution to avoid overlaps (iterative)
          function resolveOverlaps(){
            const cards = Array.from(relWrap.querySelectorAll('.relation-card'));
            if(cards.length === 0) return;
            const centerEl = focusEl.querySelector('.person-card');
            const centerW = centerEl ? centerEl.offsetWidth : 0; const centerH = centerEl ? centerEl.offsetHeight : 0;
            const padding = 8;
            const nodes = cards.map(el => ({ el, x: parseFloat(el.dataset.x)||0, y: parseFloat(el.dataset.y)||0, w: el.offsetWidth, h: el.offsetHeight }));
            const iters = 48;
            for(let iter=0; iter<iters; iter++){
              let moved = false;
              // avoid center overlap
              nodes.forEach(n => {
                if(!centerEl) return;
                const dx = n.x, dy = n.y;
                const overlapX = Math.abs(dx) < (centerW/2 + n.w/2 + padding);
                const overlapY = Math.abs(dy) < (centerH/2 + n.h/2 + padding);
                if(overlapX && overlapY){
                  moved = true;
                  let vx = dx === 0 ? 0.01 : dx; let vy = dy === 0 ? 0.01 : dy;
                  const len = Math.sqrt(vx*vx + vy*vy) || 1; vx/=len; vy/=len;
                  const needed = Math.max((centerW/2 + n.w/2 + padding) - Math.abs(dx), (centerH/2 + n.h/2 + padding) - Math.abs(dy));
                  n.x += vx * needed; n.y += vy * needed;
                }
              });
              // pairwise resolve
              for(let i=0;i<nodes.length;i++){
                for(let j=i+1;j<nodes.length;j++){
                  const a = nodes[i], b = nodes[j];
                  const dx = b.x - a.x; const dy = b.y - a.y;
                  const overlapX = Math.abs(dx) < (a.w/2 + b.w/2 + padding);
                  const overlapY = Math.abs(dy) < (a.h/2 + b.h/2 + padding);
                  if(overlapX && overlapY){
                    moved = true;
                    let vx = dx === 0 ? 0.01 : dx; let vy = dy === 0 ? 0.01 : dy;
                    const len = Math.sqrt(vx*vx + vy*vy) || 1; vx/=len; vy/=len;
                    const pushX = (a.w/2 + b.w/2 + padding) - Math.abs(dx);
                    const pushY = (a.h/2 + b.h/2 + padding) - Math.abs(dy);
                    const push = Math.max(pushX, pushY);
                    const half = push/2;
                    b.x += vx * half; b.y += vy * half; a.x -= vx * half; a.y -= vy * half;
                  }
                }
              }
              if(!moved) break;
            }
            // apply back
            nodes.forEach(n => { n.el.dataset.x = Math.round(n.x); n.el.dataset.y = Math.round(n.y); n.el.style.transform = `translate(${Math.round(n.x)}px, ${Math.round(n.y)}px)`; });
          }
          function getRelationsStore(){ try { const raw = localStorage.getItem('relations:xpto'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; } }
          const typeDesc = { siblin: 'Irmão / Irmã', ancestor: 'Pai / Mãe', child: 'Filho(a)', mate: 'Companheiro(a)' };
          if(relWrap){
            relWrap.innerHTML = '';
            const relations = getRelationsStore();
            // relations where focused person is the origin
            const relsFrom = relations.filter(r => String(r.from) === String(person.id));
            // if none, fallback to relations where focused person is the target (show the origin persons)
            const targets = [];
            if(relsFrom.length > 0){
              relsFrom.forEach(r => { if(r && r.to) targets.push({ id: r.to, type: r.type }); });
            } else {
              const relsTo = relations.filter(r => String(r.to) === String(person.id));
              relsTo.forEach(r => { if(r && r.from) targets.push({ id: r.from, type: r.type }); });
            }

            // unique by id
            const unique = Array.from(new Map(targets.map(t => [String(t.id), t])).values());

            // classify relations: parents (ancestor), children (child), siblings (siblin), others
            const parents = unique.filter(u => (u.type || '').toLowerCase() === 'ancestor');
            const children = unique.filter(u => (u.type || '').toLowerCase() === 'child');
            const siblings = unique.filter(u => (u.type || '').toLowerCase() === 'siblin');
            const others = unique.filter(u => !['ancestor','child','siblin'].includes(((u.type||'') + '').toLowerCase()));

            // helper to create card element
            function makeCard(related, relLabel){
              const name = (((related.firstName||'') + ' ' + (related.lastName||'')).trim()) || (related.name||related.fullName||related.displayName||'');
              const short = name.length > 20 ? name.slice(0,17) + '…' : name;
              const card = document.createElement('div');
              card.className = 'relation-card';
              card.setAttribute('role','button');
              card.setAttribute('tabindex','0');
              card.innerHTML = `<div class="relation-name" title="${escapeHtml(name)}">${escapeHtml(short)}</div><div class="relation-type">${escapeHtml(relLabel)}</div>`;
              card.addEventListener('click', ()=>{ renderPersonCard(related); });
              card.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'||e.key===' ') renderPersonCard(related); });
              return card;
            }

            // adaptive placement: compute spacing/radius based on counts
            // parents above: spacing reduces slightly as count grows, vertical offset grows
            if(parents.length){
              const count = parents.length;
              const spacing = Math.max(layout.parentSpacingMin, layout.parentSpacingBase - count * layout.parentSpacingDecay);
              const base = -((count-1) * spacing) / 2;
              const dy = -Math.min(layout.parentDyMax, layout.parentDyBase + count * layout.parentDyPer);
              parents.forEach((t, i) => {
                const related = all.find(x => String(x.id) === String(t.id)); if(!related) return;
                const relLabel = typeDesc[t.type] || t.type || '';
                const card = makeCard(related, relLabel);
                const dx = Math.round(base + i * spacing);
                placeCard(card, dx, dy);
                relWrap.appendChild(card);
              });
            }
            // children below: similar adaptive behaviour
            if(children.length){
              const count = children.length;
              const spacing = Math.max(layout.childSpacingMin, layout.childSpacingBase - count * layout.childSpacingDecay);
              const base = -((count-1) * spacing) / 2;
              const dy = Math.min(layout.childDyMax, layout.childDyBase + count * layout.childDyPer);
              children.forEach((t, i) => {
                const related = all.find(x => String(x.id) === String(t.id)); if(!related) return;
                const relLabel = typeDesc[t.type] || t.type || '';
                const card = makeCard(related, relLabel);
                const dx = Math.round(base + i * spacing);
                placeCard(card, dx, dy);
                relWrap.appendChild(card);
              });
            }

            // siblings: radial but radius grows with number to reduce overlap
            if(siblings.length){
              const n = siblings.length;
              const radius = Math.max(layout.siblingRadiusMin, Math.min(layout.siblingRadiusMax, layout.siblingRadiusBase + n * layout.siblingRadiusPer));
              siblings.forEach((t, i) => {
                const related = all.find(x => String(x.id) === String(t.id)); if(!related) return;
                const relLabel = typeDesc[t.type] || t.type || '';
                const angle = (i / n) * Math.PI * 2; // distribute full circle
                const dx = Math.round(Math.cos(angle) * radius);
                const dy = Math.round(Math.sin(angle) * radius);
                const card = makeCard(related, relLabel);
                placeCard(card, dx, dy);
                relWrap.appendChild(card);
              });
            }

            // others: position in two columns left/right with vertical stacking
            if(others.length){
              const colGap = layout.otherColGap;
              const rowGap = layout.otherRowGap;
            others.forEach((t, i) => {
                const related = all.find(x => String(x.id) === String(t.id)); if(!related) return;
                const relLabel = typeDesc[t.type] || t.type || '';
                const side = (i % 2 === 0) ? -1 : 1; // alternate left/right
                const idx = Math.floor(i / 2);
                const dx = side * (layout.otherColBase + idx * colGap);
                const dy = (idx % 2 === 0) ? -40 - idx * Math.round(idx * 6) : 40 + idx * Math.round(idx * 6);
                const card = makeCard(related, relLabel);
                placeCard(card, dx, dy);
                relWrap.appendChild(card);
              });
            }
          }
        }

        // read configured focused person from settings and render automatically if present
        try {
          const FOCUS_KEY = 'focusedPerson:xpto';
          const saved = JSON.parse(localStorage.getItem(FOCUS_KEY) || 'null');
          if(saved){
            let person = null;
            if(saved.id !== undefined && saved.id !== null) person = all.find(p => String(p.id) === String(saved.id));
            if(!person && saved.name){
              const targetName = (saved.name || '').trim().toLowerCase();
              person = all.find(p => (((p.firstName||'') + ' ' + (p.lastName||'')).replace(/\s+/g,' ').trim().toLowerCase() === targetName) || ((p.fullName||'') .toLowerCase() === targetName) || ((p.name||'').toLowerCase() === targetName));
            }
            if(person) renderPersonCard(person);
          }
        } catch(e){ console.warn('Erro ao carregar pessoa em foco das configurações:', e); }

        // detect direct relations
        const nodes = {};
        const edges = [];

        function addNode(p){ if(!nodes[p.id]) nodes[p.id] = p; }
        addNode(root);

        // broaden relation detection: check any field / array / nested object that references the root id
        function containsId(value, id, seen){
          if(value == null) return false;
          if(seen === undefined) seen = new Set();
          if(typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return value == id;
          if(Array.isArray(value)) return value.some(v => containsId(v, id, seen));
          if(typeof value === 'object'){
            if(seen.has(value)) return false; seen.add(value);
            return Object.values(value).some(v => containsId(v, id, seen));
          }
          return false;
        }

        function detectLabelByKey(p, id){
          // try to infer relation label by common key names
          if(p.fatherId == id || p.father == id || p.paiId == id) return 'Pai';
          if(p.motherId == id || p.mother == id || p.maeId == id) return 'Mãe';
          if(p.spouseId == id || p.partnerId == id || p.conjugeId == id) return 'Cônjuge';
          if(Array.isArray(p.parents) && p.parents.includes(id)) return 'Pai/Mãe';
          return null;
        }

        all.forEach(p => {
          if(p.id === root.id) return;
          let rel = null;

          // direct known keys
          rel = detectLabelByKey(p, root.id) || detectLabelByKey(root, p.id);

          // if any nested field in p references root.id
          if(!rel && containsId(p, root.id)) rel = 'Parente';

          // if root references p
          if(!rel && containsId(root, p.id)) rel = 'Relacionado';

          // special: relations array with typed relations
          if(!rel && Array.isArray(p.relations)){
            for(const r of p.relations){
              if(r == null) continue;
              if(r.personId == root.id || r.to == root.id || r.targetId == root.id){ rel = r.type || r.label || 'Parente'; break; }
              if(r.personId == p.id && (r.to == root.id || r.targetId == root.id)) { rel = r.type || r.label || 'Parente'; break; }
            }
          }

          if(rel){ addNode(p); edges.push({from: root.id, to: p.id, label: rel}); }
        });

        // Basic layout: root at top-center, parents above, spouses to right, children below, others left
        const w = 1000, h = 520;
        const positions = {};
        positions[root.id] = {x: w/2, y: 80};

        const parents = [], spouses = [], children = [], others = [];
        Object.values(nodes).forEach(p => { if(p.id === root.id) return; });
        edges.forEach(e=>{
          const p = nodes[e.to];
          if(!p) return;
          const label = (e.label||'').toLowerCase();
          if(label.includes('pai') || label.includes('mãe') || label.includes('pai/mãe')) parents.push(p);
          else if(label.includes('côn') || label.includes('cônjuge') || label.includes('parceiro')) spouses.push(p);
          else if(label.includes('filho')) children.push(p);
          else others.push(p);
        });

        function placeRow(arr, y, startX, spacing){
          const total = arr.length; const base = startX - ((total-1) * spacing)/2;
          arr.forEach((p,i)=> positions[p.id] = {x: base + i*spacing, y: y});
        }

        if(parents.length) placeRow(parents, 20, w/2, 160);
        if(spouses.length) placeRow(spouses, 100, (w/2)+220, 120);
        if(children.length) placeRow(children, 260, w/2, 160);
        if(others.length) placeRow(others, 180, (w/2)-260, 140);

        // draw edges
        function drawLine(x1,y1,x2,y2, label){
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2);
          line.setAttribute('stroke', '#777'); line.setAttribute('stroke-width', '2'); svg.appendChild(line);
          if(label){
            const mx = (x1+x2)/2; const my = (y1+y2)/2;
            const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
            lab.setAttribute('x', mx); lab.setAttribute('y', my - 8); lab.setAttribute('text-anchor','middle'); lab.setAttribute('fill','#444'); lab.setAttribute('font-size','12'); lab.textContent = label;
            svg.appendChild(lab);
          }
        }

        // draw nodes
        Object.values(nodes).forEach(p=>{
          const pos = positions[p.id] || {x: w/2, y: 120};
          // Invisible clickable area for the node (no visible circle or initials)
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx', pos.x); c.setAttribute('cy', pos.y); c.setAttribute('r', 30);
          c.setAttribute('fill', 'transparent'); c.setAttribute('stroke', 'transparent');
          c.setAttribute('style', 'cursor:pointer');
          c.addEventListener('click', ()=>{ renderPersonCard(p); });
          svg.appendChild(c);
        });

        // draw relation lines afterwards
        edges.forEach(e=>{
          const from = positions[e.from]; const to = positions[e.to];
          if(!from || !to) return;
          drawLine(from.x, from.y, to.x, to.y, e.label);
        });
      }

      window.addEventListener('storage', renderGraph);
      // Persisted visibility key for layout controls
      const LAYOUT_VISIBLE_KEY = 'layoutControlsVisible:xpto';

      function setLayoutControlsVisible(visible){
        try{
          const el = document.getElementById('layout-controls');
          const btn = document.getElementById('toggleLayoutControls');
          if(!el) return;
          if(visible){
            el.classList.remove('hidden');
            el.setAttribute('aria-hidden','false');
            if(btn) btn.setAttribute('aria-pressed','true');
          } else {
            el.classList.add('hidden');
            el.setAttribute('aria-hidden','true');
            if(btn) btn.setAttribute('aria-pressed','false');
          }
          try{ localStorage.setItem(LAYOUT_VISIBLE_KEY, visible ? '1' : '0'); }catch(e){}
        }catch(e){ console.warn('Failed to set layout controls visibility', e); }
      }

      // delegate click for the toggle button to avoid ordering issues
      document.addEventListener('click', function(e){
        const t = e.target;
        if(!t) return;
        if(t.id === 'toggleLayoutControls'){
          const lc = document.getElementById('layout-controls');
          const currentlyHidden = lc && lc.classList.contains('hidden');
          setLayoutControlsVisible(currentlyHidden);
        }
      });
      document.addEventListener('DOMContentLoaded', function(){
        renderGraph();
        try{ wireLayoutControls(); }catch(e){}
        // initialize layout controls visibility from localStorage (default: visible)
        try{
          const saved = localStorage.getItem(LAYOUT_VISIBLE_KEY);
          const visible = saved === null ? true : (saved === '1');
          setLayoutControlsVisible(visible);
        }catch(e){}
      });
    </script>
  </body>
</html>
