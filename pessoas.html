<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pessoas — Gráfico</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css">
  </head>
  <body>
    <div class="app-shell">
      <aside class="sidebar">
        <div class="logo"><i class="mdi mdi-tree" aria-hidden="true"></i><span>myLineage</span></div>
        <nav>
          <a href="index.html">Cadastro</a>
          <a href="indicadores.html">Indicadores</a>
          <a href="pessoas.html" class="active">Pessoas</a>
          <a href="import.html">Importar</a>
          <a href="export.html">Exportar</a>
        </nav>
        <div class="sidebar-footer">
          <a href="configuracao.html">Configuração</a>
        </div>
      </aside>
      <main class="content">
        <div class="topbar">
          <div><h1 style="margin:0;font-size:1.25rem;">Visualização gráfica de Pessoas</h1></div>
          <div>
            <button id="toggleLayoutControls" class="btn lc-toggle" aria-pressed="false" aria-controls="layout-controls">Layout</button>
            <button id="resetFocusBtn" class="btn lc-toggle" title="Resetar pessoa em foco para a definida nas configurações">Reset foco</button>
          </div>
        </div>
        <div class="card">
          <svg id="graph" viewBox="0 0 1000 520" preserveAspectRatio="xMidYMid meet"></svg>
          <div class="legend" style="margin-top:12px;">
            <div><span class="avatar" style="background:#4a90e2"></span> Masculino</div>
            <div><span class="avatar" style="background:#e26aa6"></span> Feminino</div>
            <div><span class="avatar" style="background:#9aa0a6"></span> Outro</div>
          </div>
        </div>
        <div id="person-focus" class="person-focus" aria-live="polite"></div>
        <div id="layout-controls" class="layout-controls" aria-hidden="false">
          <div class="lc-header">Layout controls</div>
          <div class="lc-row"><label>Parent spacing</label><input type="range" id="parentSpacingBase" min="100" max="320" step="10"><span id="parentSpacingBaseVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Parent vertical per</label><input type="range" id="parentDyPer" min="10" max="60" step="2"><span id="parentDyPerVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Child spacing</label><input type="range" id="childSpacingBase" min="100" max="320" step="10"><span id="childSpacingBaseVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Child vertical per</label><input type="range" id="childDyPer" min="10" max="60" step="2"><span id="childDyPerVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Sibling radius base</label><input type="range" id="siblingRadiusBase" min="60" max="220" step="5"><span id="siblingRadiusBaseVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Sibling radius per</label><input type="range" id="siblingRadiusPer" min="8" max="80" step="2"><span id="siblingRadiusPerVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Other column gap</label><input type="range" id="otherColGap" min="40" max="400" step="5"><span id="otherColGapVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Other column base</label><input type="range" id="otherColBase" min="0" max="600" step="5"><span id="otherColBaseVal" class="lc-val"></span></div>
          <div class="lc-row"><label>Other row gap</label><input type="range" id="otherRowGap" min="20" max="240" step="2"><span id="otherRowGapVal" class="lc-val"></span></div>
          <div class="lc-row buttons"><button id="resetLayout" class="btn">Reset</button></div>
        </div>
      </main>
    </div>
    <script>
      function getPeople() {
        try { const raw = localStorage.getItem('people:myLineage'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; }
      }

      // Photos helpers (thumbnails)
      function getPhotos(){ try{ const raw = localStorage.getItem('photos:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function getPhotoRelations(){ try{ const raw = localStorage.getItem('photoRelations:myLineage'); return raw ? JSON.parse(raw) : {}; }catch(e){ return {}; } }
      function genderPlaceholder(g){ const gender = (g||'').toString().toLowerCase(); const color = (gender==='female' || gender==='feminino' || gender==='f') ? '#e26aa6' : (gender==='male' || gender==='masculino' || gender==='m') ? '#4a90e2' : '#9aa0a6'; const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'><rect width='100%' height='100%' fill='${color}' rx='12'/><g fill='white' transform='translate(20,18)'><circle cx='40' cy='26' r='18'/><path d='M4 92c0-22 72-22 72 0v4H4v-4z' fill-opacity='0.95'/></g></svg>`; return 'data:image/svg+xml;base64,' + btoa(svg); }
      function getThumbnailForPerson(personId){ try{ const rels = getPhotoRelations(); const photos = getPhotos(); const ids = rels[personId] || []; if(Array.isArray(ids) && ids.length){ for(const id of ids){ const ph = photos.find(p=>String(p.id)===String(id)); if(ph){ return ph.originalDataUrl || ph.dataUrl || null; } } } return null; }catch(e){ return null; } }

      // connect layout-controls sliders to LayoutSettings
      function wireLayoutControls(){
        try{
          const map = {
            parentSpacingBase: 'parentSpacingBase', parentDyPer: 'parentDyPer',
            childSpacingBase: 'childSpacingBase', childDyPer: 'childDyPer',
            siblingRadiusBase: 'siblingRadiusBase', siblingRadiusPer: 'siblingRadiusPer',
            otherColGap: 'otherColGap', otherRowGap: 'otherRowGap', otherColBase: 'otherColBase'
          };
          Object.keys(map).forEach(id => {
            const el = document.getElementById(id);
            if(!el) return;
            // set initial value from LayoutSettings
            el.value = LayoutSettings[map[id]] || el.min || 0;
            // update numeric display
            const valEl = document.getElementById(id + 'Val'); if(valEl) valEl.textContent = el.value;
            el.addEventListener('input', function(){
              LayoutSettings[map[id]] = Number(this.value);
              saveLayoutSettings(LayoutSettings);
              const vEl = document.getElementById(id + 'Val'); if(vEl) vEl.textContent = this.value;
              // re-render graph to apply changes (keeps focus)
              try{ renderGraph(); } catch(e){}
            });
          });
          const reset = document.getElementById('resetLayout');
          if(reset) reset.addEventListener('click', function(){
            // reset to defaults
            LayoutSettings = loadLayoutSettings();
            Object.assign(LayoutSettings, DEFAULT_LayoutSettings);
            saveLayoutSettings(LayoutSettings);
            // update sliders
            Object.keys(map).forEach(id => { const el = document.getElementById(id); if(el) el.value = LayoutSettings[map[id]]; const vEl = document.getElementById(id + 'Val'); if(vEl) vEl.textContent = el.value; });
            renderGraph();
          });
        }catch(e){ console.warn('Layout controls wiring failed', e); }
      }
      function getEvents() {
        try { const raw = localStorage.getItem('events:myLineage'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; }
      }
      function formatDate(d){ if(!d) return ''; const t=new Date(d); if(isNaN(t)) return d; return t.getDate().toString().padStart(2,'0') + '-' + (t.getMonth()+1).toString().padStart(2,'0') + '-' + t.getFullYear(); }
      function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

      // Runtime layout settings (editable by UI sliders). Persisted in localStorage under 'layoutSettings:myLineage'
      const DEFAULT_LayoutSettings = {
        parentSpacingBase: 200, parentSpacingDecay: 10, parentSpacingMin: 90,
        parentDyBase: 120, parentDyPer: 30, parentDyMax: 360,
        childSpacingBase: 200, childSpacingDecay: 10, childSpacingMin: 90,
        childDyBase: 120, childDyPer: 30, childDyMax: 360,
        siblingRadiusBase: 110, siblingRadiusPer: 36, siblingRadiusMin: 140, siblingRadiusMax: 520,
        otherColGap: 140, otherRowGap: 80, otherColBase: 200
      };

      const LAYOUT_KEY = 'layoutSettings:myLineage';
      function loadLayoutSettings(){
        try{ const raw = localStorage.getItem(LAYOUT_KEY); if(!raw) return {...DEFAULT_LayoutSettings}; const obj = JSON.parse(raw); return Object.assign({}, DEFAULT_LayoutSettings, obj); }catch(e){ return {...DEFAULT_LayoutSettings}; }
      }
      function saveLayoutSettings(obj){ try{ localStorage.setItem(LAYOUT_KEY, JSON.stringify(obj)); }catch(e){}
      }
      let LayoutSettings = loadLayoutSettings();
      // Runtime-only focused person (does not overwrite configured focus in settings)
      let RuntimeFocus = null;

      // Render only Miguel and direct relations in a simple family-tree layout
      function renderGraph(){
        const all = getPeople().filter(p => !p.deletedAt);
        const svg = document.getElementById('graph');
        svg.innerHTML = '';
        if(all.length === 0){
          const msg = document.createElementNS('http://www.w3.org/2000/svg','text');
          msg.setAttribute('x','50%'); msg.setAttribute('y','50%'); msg.setAttribute('text-anchor','middle'); msg.setAttribute('fill','#888'); msg.setAttribute('font-size','18'); msg.textContent = 'Nenhuma pessoa cadastrada.';
          svg.appendChild(msg); return;
        }

        // pick root person: prefer runtime focus (navigating) then configured focused person (settings), else first person
        function fullname(p){ return ((p.firstName||'') + ' ' + (p.lastName||'')).replace(/\s+/g,' ').trim(); }
        let root = null;
        try{
          // 1) runtime focus (set when user navigates between people) — does NOT overwrite user settings
          if(RuntimeFocus){
            if(RuntimeFocus.id !== undefined && RuntimeFocus.id !== null){ root = all.find(p => String(p.id) === String(RuntimeFocus.id)); }
            if(!root && RuntimeFocus.name){ const targetName = (RuntimeFocus.name || '').trim().toLowerCase(); root = all.find(p => fullname(p).toLowerCase() === targetName || ((p.fullName||'').toLowerCase() === targetName) || ((p.name||'').toLowerCase() === targetName)); }
          }
          // 2) configured focus from settings (persisted)
          if(!root){
            const FOCUS_KEY = 'focusedPerson:myLineage';
            const saved = JSON.parse(localStorage.getItem(FOCUS_KEY) || 'null');
            if(saved){
              if(saved.id !== undefined && saved.id !== null){ root = all.find(p => String(p.id) === String(saved.id)); }
              if(!root && saved.name){ const targetName = (saved.name || '').trim().toLowerCase(); root = all.find(p => fullname(p).toLowerCase() === targetName || ((p.fullName||'').toLowerCase() === targetName) || ((p.name||'').toLowerCase() === targetName)); }
            }
          }
        }catch(e){ /* ignore */ }
        if(!root) root = all[0];

        // helper: render person card into the central container
        function renderPersonCard(person){
          const focusEl = document.getElementById('person-focus');
          if(!person){ focusEl.innerHTML = ''; return; }
          const evs = getEvents().filter(ev=>ev.personId === person.id && !ev.deletedAt);
          const birth = evs.find(e=>e.type === 'BIRTH');
          const death = evs.find(e=>e.type === 'DEATH');
          const fullName = ((person.firstName||'') + ' ' + (person.lastName||'')).trim();
          const shortName = fullName.length > 36 ? fullName.slice(0,33) + '…' : fullName;
          const thumb = getThumbnailForPerson(person.id) || genderPlaceholder(person.gender);
          focusEl.innerHTML = `
            <div class="person-card" role="article" aria-label="Pessoa em foco">
              <img class="person-avatar" src="${thumb}" alt="avatar">
              <div style="display:flex;flex-direction:column;align-items:flex-start;gap:6px;flex:1;">
                <div style="display:flex;align-items:center;gap:8px;justify-content:space-between;width:100%">
                  <div class="person-name" title="${fullName}">${shortName}</div>
                  <a class="person-detail-link" href="pessoa-detalhe.html?id=${encodeURIComponent(person.id)}" title="Ver detalhe" aria-label="Abrir detalhe da pessoa" style="color:var(--text-secondary);text-decoration:none;display:inline-flex;align-items:center;gap:6px;">
                    <i class="mdi mdi-open-in-new" style="font-size:18px;" aria-hidden="true"></i>
                  </a>
                </div>
                <div class="person-dates" aria-hidden="false">
                  <div class="person-date person-birth">
                    <i class="mdi mdi-cake" style="font-size:14px;" aria-hidden="true"></i>
                    <div class="date-text">${birth && birth.date ? formatDate(birth.date) : ''}</div>
                  </div>
                  <div class="person-date person-death">
                    <i class="mdi mdi-skull" style="font-size:14px;" aria-hidden="true"></i>
                    <div class="date-text">${death && death.date ? formatDate(death.date) : ''}</div>
                  </div>
                </div>
              </div>
            </div>
            <div class="relations-container" aria-hidden="false"></div>
          `;

          // set runtime focus (do not overwrite user's configured focus in settings)
          try{
            RuntimeFocus = { id: person.id, name: fullName };
          }catch(e){ /* ignore */ }

          // render related person cards around the focus card using relations stored in localStorage ('relations:myLineage')
          const relWrap = focusEl.querySelector('.relations-container');
          // use runtime LayoutSettings (modifiable via UI)
          const layout = LayoutSettings;
          function placeCard(el, dx, dy){ el.dataset.x = dx; el.dataset.y = dy; el.style.transform = `translate(${dx}px, ${dy}px)`; }

          // collision resolution to avoid overlaps (iterative)
          function resolveOverlaps(){
            const cards = Array.from(relWrap.querySelectorAll('.relation-card'));
            if(cards.length === 0) return;
            const centerEl = focusEl.querySelector('.person-card');
            const centerW = centerEl ? centerEl.offsetWidth : 0; const centerH = centerEl ? centerEl.offsetHeight : 0;
            const padding = 8;
            const nodes = cards.map(el => ({ el, x: parseFloat(el.dataset.x)||0, y: parseFloat(el.dataset.y)||0, w: el.offsetWidth, h: el.offsetHeight }));
            const iters = 48;
            for(let iter=0; iter<iters; iter++){
              let moved = false;
              // avoid center overlap
              nodes.forEach(n => {
                if(!centerEl) return;
                const dx = n.x, dy = n.y;
                const overlapX = Math.abs(dx) < (centerW/2 + n.w/2 + padding);
                const overlapY = Math.abs(dy) < (centerH/2 + n.h/2 + padding);
                if(overlapX && overlapY){
                  moved = true;
                  let vx = dx === 0 ? 0.01 : dx; let vy = dy === 0 ? 0.01 : dy;
                  const len = Math.sqrt(vx*vx + vy*vy) || 1; vx/=len; vy/=len;
                  const needed = Math.max((centerW/2 + n.w/2 + padding) - Math.abs(dx), (centerH/2 + n.h/2 + padding) - Math.abs(dy));
                  n.x += vx * needed; n.y += vy * needed;
                }
              });
              // pairwise resolve
              for(let i=0;i<nodes.length;i++){
                for(let j=i+1;j<nodes.length;j++){
                  const a = nodes[i], b = nodes[j];
                  const dx = b.x - a.x; const dy = b.y - a.y;
                  const overlapX = Math.abs(dx) < (a.w/2 + b.w/2 + padding);
                  const overlapY = Math.abs(dy) < (a.h/2 + b.h/2 + padding);
                  if(overlapX && overlapY){
                    moved = true;
                    let vx = dx === 0 ? 0.01 : dx; let vy = dy === 0 ? 0.01 : dy;
                    const len = Math.sqrt(vx*vx + vy*vy) || 1; vx/=len; vy/=len;
                    const pushX = (a.w/2 + b.w/2 + padding) - Math.abs(dx);
                    const pushY = (a.h/2 + b.h/2 + padding) - Math.abs(dy);
                    const push = Math.max(pushX, pushY);
                    const half = push/2;
                    b.x += vx * half; b.y += vy * half; a.x -= vx * half; a.y -= vy * half;
                  }
                }
              }
              if(!moved) break;
            }
            // apply back
            nodes.forEach(n => { n.el.dataset.x = Math.round(n.x); n.el.dataset.y = Math.round(n.y); n.el.style.transform = `translate(${Math.round(n.x)}px, ${Math.round(n.y)}px)`; });
          }
          function getRelationsStore(){ try { const raw = localStorage.getItem('relations:myLineage'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; } }
          const typeDesc = { siblin: 'Irmão / Irmã', ancestor: 'Pai / Mãe', child: 'Filho(a)', mate: 'Companheiro(a)' };
          if(relWrap){
            relWrap.innerHTML = '';
            const relations = getRelationsStore();
            // collect relations where focused person is origin (from) or target (to)
            const relsFrom = relations.filter(r => String(r.from) === String(person.id));
            const relsTo = relations.filter(r => String(r.to) === String(person.id));
            const targets = [];
            function normalizeType(t){ if(!t) return ''; return (''+t).toLowerCase(); }
            function invertType(t){ const n = normalizeType(t); if(n === 'ancestor') return 'child'; if(n === 'child') return 'ancestor'; return n; }
            // relations originating from focused person -> related persons are in `to` (keep type)
            relsFrom.forEach(r => { if(r && r.to) targets.push({ id: r.to, type: normalizeType(r.type) }); });
            // relations targeting focused person -> related persons are in `from` (invert type so child->parent stored as 'ancestor' becomes 'child' for display)
            relsTo.forEach(r => { if(r && r.from) targets.push({ id: r.from, type: invertType(r.type) }); });

            // also include children discovered by scanning people records (e.g. fatherId/motherId/parents arrays)
            try{
              all.forEach(rp => {
                if(!rp || rp.id === undefined || rp.id === null) return;
                if(String(rp.id) === String(person.id)) return;
                const isChild = (String(rp.fatherId) === String(person.id)) || (String(rp.motherId) === String(person.id)) || (Array.isArray(rp.parents) && rp.parents.map(String).includes(String(person.id)));
                if(isChild){ targets.push({ id: rp.id, type: 'child' }); }
              });
            }catch(e){ /* ignore scanning errors */ }

            // unique by id
            const unique = Array.from(new Map(targets.map(t => [String(t.id), t])).values());

            // classify relations: parents (ancestor), children (child), siblings (siblin), others
            const parents = unique.filter(u => (u.type || '').toLowerCase() === 'ancestor');
            const children = unique.filter(u => (u.type || '').toLowerCase() === 'child');
            const siblings = unique.filter(u => (u.type || '').toLowerCase() === 'siblin');
            const others = unique.filter(u => !['ancestor','child','siblin'].includes(((u.type||'') + '').toLowerCase()));

            // helper to create card element
            function makeCard(related, relLabel){
              const name = (((related.firstName||'') + ' ' + (related.lastName||'')).trim()) || (related.name||related.fullName||related.displayName||'');
              const short = name.length > 20 ? name.slice(0,17) + '…' : name;
              // determine gendered label for child relations
              try{
                const tlabel = ('' + (relLabel || '')).toLowerCase();
                if(tlabel.includes('filho')){
                  const g = (related.gender || related.sex || '').toString().toLowerCase();
                  if(g === 'female' || g === 'feminino' || g === 'f') relLabel = 'Filha';
                  else if(g === 'male' || g === 'masculino' || g === 'm') relLabel = 'Filho';
                  else relLabel = 'Filho(a)';
                }
                // handle generic parent label "Pai / Mãe"
                if(tlabel.includes('pai') || tlabel.includes('mãe') || tlabel.includes('pai/mãe') || tlabel.includes('pai / mãe')){
                  const g = (related.gender || related.sex || '').toString().toLowerCase();
                  if(g === 'female' || g === 'feminino' || g === 'f') relLabel = 'Mãe';
                  else if(g === 'male' || g === 'masculino' || g === 'm') relLabel = 'Pai';
                  else relLabel = 'Pai / Mãe';
                }
                // handle companion/partner label "Companheiro(a)"
                if(tlabel.includes('compan') || tlabel.includes('parceiro') || tlabel.includes('côn') || tlabel.includes('conjuge') || tlabel.includes('mate') || tlabel.includes('spouse') || tlabel.includes('partner')){
                  const g = (related.gender || related.sex || '').toString().toLowerCase();
                  if(g === 'female' || g === 'feminino' || g === 'f') relLabel = 'Companheira';
                  else if(g === 'male' || g === 'masculino' || g === 'm') relLabel = 'Companheiro';
                  else relLabel = 'Companheiro(a)';
                }
                // handle siblings label "Irmão / Irmã"
                if(tlabel.includes('irm') || tlabel.includes('siblin') || tlabel.includes('sibling')){
                  const g = (related.gender || related.sex || '').toString().toLowerCase();
                  if(g === 'female' || g === 'feminino' || g === 'f') relLabel = 'Irmã';
                  else if(g === 'male' || g === 'masculino' || g === 'm') relLabel = 'Irmão';
                  else relLabel = 'Irmão / Irmã';
                }
              }catch(e){ /* ignore */ }

              const card = document.createElement('div');
              card.className = 'relation-card';
              card.setAttribute('role','button');
              card.setAttribute('tabindex','0');
              const thumb = getThumbnailForPerson(related.id) || genderPlaceholder(related.gender);
              card.innerHTML = `<div style="display:flex;align-items:center;gap:8px;width:100%"><img class="relation-avatar" src="${thumb}" alt="avatar"/><div style="flex:1"><div class="relation-name" title="${escapeHtml(name)}">${escapeHtml(short)}</div><div class="relation-type">${escapeHtml(relLabel)}</div></div></div>`;
              card.addEventListener('click', ()=>{ renderPersonCard(related); });
              card.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'||e.key===' ') renderPersonCard(related); });
              return card;
            }

            // adaptive placement: compute spacing/radius based on counts
            // parents above: spacing reduces slightly as count grows, vertical offset grows
            if(parents.length){
              const count = parents.length;
              const spacing = Math.max(layout.parentSpacingMin, layout.parentSpacingBase - count * layout.parentSpacingDecay);
              const base = -((count-1) * spacing) / 2;
              const dy = -Math.min(layout.parentDyMax, layout.parentDyBase + count * layout.parentDyPer);
              parents.forEach((t, i) => {
                const related = all.find(x => String(x.id) === String(t.id)); if(!related) return;
                const relLabel = typeDesc[t.type] || t.type || '';
                const card = makeCard(related, relLabel);
                const dx = Math.round(base + i * spacing);
                placeCard(card, dx, dy);
                relWrap.appendChild(card);
              });
            }
            // children below: similar adaptive behaviour
            if(children.length){
              const count = children.length;
              const spacing = Math.max(layout.childSpacingMin, layout.childSpacingBase - count * layout.childSpacingDecay);
              const base = -((count-1) * spacing) / 2;
              const dy = Math.min(layout.childDyMax, layout.childDyBase + count * layout.childDyPer);
              children.forEach((t, i) => {
                const related = all.find(x => String(x.id) === String(t.id)); if(!related) return;
                const relLabel = typeDesc[t.type] || t.type || '';
                const card = makeCard(related, relLabel);
                const dx = Math.round(base + i * spacing);
                placeCard(card, dx, dy);
                relWrap.appendChild(card);
              });
            }

            // siblings: radial but radius grows with number to reduce overlap
            if(siblings.length){
              const n = siblings.length;
              const radius = Math.max(layout.siblingRadiusMin, Math.min(layout.siblingRadiusMax, layout.siblingRadiusBase + n * layout.siblingRadiusPer));
              siblings.forEach((t, i) => {
                const related = all.find(x => String(x.id) === String(t.id)); if(!related) return;
                const relLabel = typeDesc[t.type] || t.type || '';
                const angle = (i / n) * Math.PI * 2; // distribute full circle
                const dx = Math.round(Math.cos(angle) * radius);
                const dy = Math.round(Math.sin(angle) * radius);
                const card = makeCard(related, relLabel);
                placeCard(card, dx, dy);
                relWrap.appendChild(card);
              });
            }

            // others: position in two columns left/right with vertical stacking
            if(others.length){
              const colGap = layout.otherColGap;
              const rowGap = layout.otherRowGap;
            others.forEach((t, i) => {
                const related = all.find(x => String(x.id) === String(t.id)); if(!related) return;
                const relLabel = typeDesc[t.type] || t.type || '';
                const side = (i % 2 === 0) ? -1 : 1; // alternate left/right
                const idx = Math.floor(i / 2);
                const dx = side * (layout.otherColBase + idx * colGap);
                const dy = (idx % 2 === 0) ? -40 - idx * Math.round(idx * 6) : 40 + idx * Math.round(idx * 6);
                const card = makeCard(related, relLabel);
                placeCard(card, dx, dy);
                relWrap.appendChild(card);
              });
            }
          }
        }

        // only render configured focused person automatically if there is no runtime focus
        try {
          if(!RuntimeFocus){
            const FOCUS_KEY = 'focusedPerson:myLineage';
            const saved = JSON.parse(localStorage.getItem(FOCUS_KEY) || 'null');
            if(saved){
              let person = null;
              if(saved.id !== undefined && saved.id !== null) person = all.find(p => String(p.id) === String(saved.id));
              if(!person && saved.name){
                const targetName = (saved.name || '').trim().toLowerCase();
                person = all.find(p => (((p.firstName||'') + ' ' + (p.lastName||'')).replace(/\s+/g,' ').trim().toLowerCase() === targetName) || ((p.fullName||'') .toLowerCase() === targetName) || ((p.name||'').toLowerCase() === targetName));
              }
              if(person) renderPersonCard(person);
            }
          }
        } catch(e){ console.warn('Erro ao carregar pessoa em foco das configurações:', e); }

        // detect direct relations
        const nodes = {};
        const edges = [];

        function addNode(p){ if(!nodes[p.id]) nodes[p.id] = p; }
        addNode(root);

        // broaden relation detection: check any field / array / nested object that references the root id
        function containsId(value, id, seen){
          if(value == null) return false;
          if(seen === undefined) seen = new Set();
          if(typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return value == id;
          if(Array.isArray(value)) return value.some(v => containsId(v, id, seen));
          if(typeof value === 'object'){
            if(seen.has(value)) return false; seen.add(value);
            return Object.values(value).some(v => containsId(v, id, seen));
          }
          return false;
        }

        function detectLabelByKey(p, id){
          // try to infer relation label by common key names
          if(p.fatherId == id || p.father == id || p.paiId == id) return 'Pai';
          if(p.motherId == id || p.mother == id || p.maeId == id) return 'Mãe';
          if(p.spouseId == id || p.partnerId == id || p.conjugeId == id) return 'Cônjuge';
          if(Array.isArray(p.parents) && p.parents.includes(id)) return 'Pai/Mãe';
          return null;
        }

        all.forEach(p => {
          if(p.id === root.id) return;
          let rel = null;

          // explicit detection: if candidate references root as parent, candidate is a child
          try{
            if((p.fatherId !== undefined && String(p.fatherId) === String(root.id)) || (p.motherId !== undefined && String(p.motherId) === String(root.id)) || (Array.isArray(p.parents) && p.parents.map(String).includes(String(root.id)))){
              rel = 'Filho';
            } else if((root.fatherId !== undefined && String(root.fatherId) === String(p.id)) || (root.motherId !== undefined && String(root.motherId) === String(p.id)) || (Array.isArray(root.parents) && root.parents.map(String).includes(String(p.id)))){
              // candidate is parent of root
              if(root.fatherId !== undefined && String(root.fatherId) === String(p.id)) rel = 'Pai';
              else if(root.motherId !== undefined && String(root.motherId) === String(p.id)) rel = 'Mãe';
              else rel = 'Pai/Mãe';
            }
          }catch(e){ /* ignore */ }

          // direct known keys and other heuristics (fallback)
          if(!rel) rel = detectLabelByKey(p, root.id) || detectLabelByKey(root, p.id);

          // if any nested field in p references root.id
          if(!rel && containsId(p, root.id)) rel = 'Parente';

          // if root references p
          if(!rel && containsId(root, p.id)) rel = 'Relacionado';

          // special: relations array with typed relations
          if(!rel && Array.isArray(p.relations)){
            for(const r of p.relations){
              if(r == null) continue;
              if(r.personId == root.id || r.to == root.id || r.targetId == root.id){ rel = r.type || r.label || 'Parente'; break; }
              if(r.personId == p.id && (r.to == root.id || r.targetId == root.id)) { rel = r.type || r.label || 'Parente'; break; }
            }
          }

          if(rel){ addNode(p); edges.push({from: root.id, to: p.id, label: rel}); }
        });

        // Basic layout: root at top-center, parents above, spouses to right, children below, others left
        const w = 1000, h = 520;
        const positions = {};
        positions[root.id] = {x: w/2, y: 80};

        const parents = [], spouses = [], children = [], others = [];
        Object.values(nodes).forEach(p => { if(p.id === root.id) return; });
        edges.forEach(e=>{
          const p = nodes[e.to];
          if(!p) return;
          const label = (e.label||'').toLowerCase();
          // accept both Portuguese and common English relation types
          if(label.includes('pai') || label.includes('mãe') || label.includes('pai/mãe') || label.includes('ancestor') || label.includes('parent')) parents.push(p);
          else if(label.includes('côn') || label.includes('cônjuge') || label.includes('parceiro') || label.includes('mate') || label.includes('spouse') || label.includes('conjuge')) spouses.push(p);
          else if(label.includes('filho') || label.includes('child')) children.push(p);
          else others.push(p);
        });

        function placeRow(arr, y, startX, spacing){
          const total = arr.length; const base = startX - ((total-1) * spacing)/2;
          arr.forEach((p,i)=> positions[p.id] = {x: base + i*spacing, y: y});
        }

        if(parents.length) placeRow(parents, 20, w/2, 160);
        if(spouses.length) placeRow(spouses, 100, (w/2)+220, 120);
        if(children.length) placeRow(children, 260, w/2, 160);
        if(others.length) placeRow(others, 180, (w/2)-260, 140);

        // draw edges
        function drawLine(x1,y1,x2,y2, label){
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2);
          line.setAttribute('stroke', '#777'); line.setAttribute('stroke-width', '2'); svg.appendChild(line);
          if(label){
            const mx = (x1+x2)/2; const my = (y1+y2)/2;
            const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
            lab.setAttribute('x', mx); lab.setAttribute('y', my - 8); lab.setAttribute('text-anchor','middle'); lab.setAttribute('fill','#444'); lab.setAttribute('font-size','12'); lab.textContent = label;
            svg.appendChild(lab);
          }
        }

        // draw nodes
        Object.values(nodes).forEach(p=>{
          const pos = positions[p.id] || {x: w/2, y: 120};
          // Invisible clickable area for the node (no visible circle or initials)
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx', pos.x); c.setAttribute('cy', pos.y); c.setAttribute('r', 30);
          c.setAttribute('fill', 'transparent'); c.setAttribute('stroke', 'transparent');
          c.setAttribute('style', 'cursor:pointer');
          c.addEventListener('click', ()=>{ renderPersonCard(p); });
          svg.appendChild(c);
        });

        // draw relation lines afterwards (label may be adjusted based on related person's gender)
        edges.forEach(e=>{
          const from = positions[e.from]; const to = positions[e.to];
          if(!from || !to) return;
          let label = e.label || '';
          try{
            const labLow = (label || '').toString().toLowerCase();
            if(labLow.includes('filho')){
              const target = nodes[e.to];
              const g = (target && (target.gender || target.sex)) ? String(target.gender || target.sex).toLowerCase() : '';
              if(g === 'female' || g === 'feminino' || g === 'f') label = 'Filha';
              else if(g === 'male' || g === 'masculino' || g === 'm') label = 'Filho';
              else label = 'Filho(a)';
            }
            // adjust parent edge labels (Pai / Mãe)
            if(labLow.includes('pai') || labLow.includes('mãe') || labLow.includes('pai/mãe') || labLow.includes('pai / mãe')){
              const target = nodes[e.to];
              const g = (target && (target.gender || target.sex)) ? String(target.gender || target.sex).toLowerCase() : '';
              if(g === 'female' || g === 'feminino' || g === 'f') label = 'Mãe';
              else if(g === 'male' || g === 'masculino' || g === 'm') label = 'Pai';
              else label = 'Pai / Mãe';
            }
            // adjust companion/partner edge labels (Companheiro(a))
            if(labLow.includes('compan') || labLow.includes('parceiro') || labLow.includes('côn') || labLow.includes('conjuge') || labLow.includes('mate') || labLow.includes('spouse') || labLow.includes('partner')){
              const target = nodes[e.to];
              const g = (target && (target.gender || target.sex)) ? String(target.gender || target.sex).toLowerCase() : '';
              if(g === 'female' || g === 'feminino' || g === 'f') label = 'Companheira';
              else if(g === 'male' || g === 'masculino' || g === 'm') label = 'Companheiro';
              else label = 'Companheiro(a)';
            }
            // adjust sibling edge labels (Irmão / Irmã)
            if(labLow.includes('irm') || labLow.includes('siblin') || labLow.includes('sibling')){
              const target = nodes[e.to];
              const g = (target && (target.gender || target.sex)) ? String(target.gender || target.sex).toLowerCase() : '';
              if(g === 'female' || g === 'feminino' || g === 'f') label = 'Irmã';
              else if(g === 'male' || g === 'masculino' || g === 'm') label = 'Irmão';
              else label = 'Irmão / Irmã';
            }
          }catch(e){ /* ignore */ }
          drawLine(from.x, from.y, to.x, to.y, label);
        });
      }

      window.addEventListener('storage', renderGraph);
      // Persisted visibility key for layout controls
      const LAYOUT_VISIBLE_KEY = 'layoutControlsVisible:myLineage';

      function setLayoutControlsVisible(visible){
        try{
          const el = document.getElementById('layout-controls');
          const btn = document.getElementById('toggleLayoutControls');
          if(!el) return;
          if(visible){
            el.classList.remove('hidden');
            el.setAttribute('aria-hidden','false');
            if(btn) btn.setAttribute('aria-pressed','true');
          } else {
            el.classList.add('hidden');
            el.setAttribute('aria-hidden','true');
            if(btn) btn.setAttribute('aria-pressed','false');
          }
          try{ localStorage.setItem(LAYOUT_VISIBLE_KEY, visible ? '1' : '0'); }catch(e){}
        }catch(e){ console.warn('Failed to set layout controls visibility', e); }
      }

      // delegate click for the topbar buttons to avoid ordering issues
      document.addEventListener('click', function(e){
        const t = e.target;
        if(!t) return;
        if(t.id === 'toggleLayoutControls'){
          const lc = document.getElementById('layout-controls');
          const currentlyHidden = lc && lc.classList.contains('hidden');
          setLayoutControlsVisible(currentlyHidden);
        }
        if(t.id === 'resetFocusBtn'){
          try{
            // clear runtime focus (so the configured focus in settings is used)
            RuntimeFocus = null;
            // reload the page so renderGraph picks up the configured focus from localStorage
            location.reload();
          }catch(e){ console.warn('Reset focus failed', e); }
        }
      });
      document.addEventListener('DOMContentLoaded', function(){
        renderGraph();
        try{ wireLayoutControls(); }catch(e){}
        // initialize layout controls visibility from localStorage (default: visible)
        try{
          const saved = localStorage.getItem(LAYOUT_VISIBLE_KEY);
          const visible = saved === null ? true : (saved === '1');
          setLayoutControlsVisible(visible);
        }catch(e){}
      });
    </script>
  </body>
</html>
