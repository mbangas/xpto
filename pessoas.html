<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pessoas — Gráfico</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css">
    <!-- Cytoscape and dagre for hierarchical layout -->
    <script src="https://unpkg.com/cytoscape@3.24.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.3.2/cytoscape-dagre.js"></script>
    <style>
      /* small adjustments for Cytoscape container and node labels */
      #cy { background: #fafafa; border-radius:8px; }
      .cy-node-label { font-size:12px; font-weight:600; color:#222; }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <aside class="sidebar">
        <div class="logo"><i class="mdi mdi-tree" aria-hidden="true"></i><span>myLineage</span></div>
        <nav>
          <a href="index.html"><i class="mdi mdi-account-multiple" aria-hidden="true"></i>Cadastro</a>
          <a href="indicadores.html"><i class="mdi mdi-chart-bar" aria-hidden="true"></i>Indicadores</a>
          <a href="pessoas.html" class="active"><i class="mdi mdi-account" aria-hidden="true"></i>Pessoas</a>
          <a href="arvore.html"><i class="mdi mdi-sitemap" aria-hidden="true"></i>Árvore</a>
          <a href="import.html"><i class="mdi mdi-file-import" aria-hidden="true"></i>Importar</a>
          <a href="export.html"><i class="mdi mdi-file-export" aria-hidden="true"></i>Exportar</a>
        </nav>
        <div class="sidebar-footer">
          <a href="configuracao.html"><i class="mdi mdi-cog" aria-hidden="true"></i>Definições</a>
        </div>
      </aside>
      <main class="content">
        <div class="topbar">
          <div><h1 style="margin:0;font-size:1.25rem;">Visualização gráfica de Pessoas</h1></div>
          <div>
            <button id="toggleLayoutControls" class="btn lc-toggle" aria-pressed="false" aria-controls="layout-controls">Layout</button>
            <button id="resetFocusBtn" class="btn lc-toggle" title="Resetar pessoa em foco para a definida nas configurações">Reset foco</button>
          </div>
        </div>

        <div class="card">
          <div id="cy" style="width:100%;height:620px;"></div>
          <div class="legend" style="margin-top:12px;">
            <div><span class="avatar" style="background:#4a90e2"></span> Masculino</div>
            <div><span class="avatar" style="background:#e26aa6"></span> Feminino</div>
            <div><span class="avatar" style="background:#9aa0a6"></span> Outro</div>
          </div>
        </div>

        <div id="person-focus" class="person-focus" aria-live="polite"></div>

        <div id="layout-controls" class="layout-controls" aria-hidden="false">
          <div class="lc-header">Layout controls</div>
          <div class="lc-row"><label>Rank direction</label>
            <select id="rankDir"><option value="TB">Top &rarr; Down</option><option value="LR">Left &rarr; Right</option></select>
          </div>
          <div class="lc-row buttons"><button id="resetLayout" class="btn">Reset</button></div>
        </div>

      </main>
    </div>

    <script>
      // Helpers (localStorage-backed data)
      function getPeople(){ try{ const raw = localStorage.getItem('people:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function getPhotos(){ try{ const raw = localStorage.getItem('photos:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function getPhotoRelations(){ try{ const raw = localStorage.getItem('photoRelations:myLineage'); return raw ? JSON.parse(raw) : {}; }catch(e){ return {}; } }
      function getEvents(){ try{ const raw = localStorage.getItem('events:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function genderPlaceholder(g){
        const gender = (g||'').toString().toLowerCase();
        const color = (gender==='female' || gender==='feminino' || gender==='f') ? '#e26aa6' : (gender==='male' || gender==='masculino' || gender==='m') ? '#4a90e2' : '#9aa0a6';
        // simple silhouette on colored rounded rect background
        const svg = `<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 120 120'>
          <rect width='100%' height='100%' fill='${color}' rx='12'/>
          <g fill='#ffffff' transform='translate(30,20)'>
            <circle cx='30' cy='24' r='16'/>
            <path d='M6 80c0-18 36-18 48-18s48 0 48 18v6H6v-6z' />
          </g>
        </svg>`;
        return 'data:image/svg+xml;base64,' + base64EncodeUnicode(svg);
      }
      // base64 encode supporting Unicode characters
      function base64EncodeUnicode(str) {
        try{
          return btoa(unescape(encodeURIComponent(str)));
        }catch(e){
          // fallback to plain btoa if above fails
          return btoa(str);
        }
      }
      function getThumbnailForPerson(personId){ try{ const rels = getPhotoRelations(); const photos = getPhotos(); const ids = rels[personId] || []; if(Array.isArray(ids) && ids.length){ for(const id of ids){ const ph = photos.find(p=>String(p.id)===String(id)); if(ph){ return ph.originalDataUrl || ph.dataUrl || null; } } } return null; }catch(e){ return null; } }

      // ensure RuntimeFocus exists on window for compatibility
      window.RuntimeFocus = window.RuntimeFocus || null;

      // Build a focused subgraph: focused person -> ancestors (upwards), siblings, partner(s), children
      function buildGraphData(){
        const people = getPeople().filter(p=>!p.deletedAt);
        const idMap = new Map(people.map(p=>[String(p.id), p]));
        // determine focus id: RuntimeFocus if set, otherwise persisted focus, otherwise first person
        function getFocusId(){
          if(window.RuntimeFocus && window.RuntimeFocus.id) return String(window.RuntimeFocus.id);
          try{
            const saved = JSON.parse(localStorage.getItem('focusedPerson:myLineage') || 'null');
            if(saved){ if(saved.id) return String(saved.id); if(saved.name){ const name = (saved.name||'').trim().toLowerCase(); const found = people.find(p => (((p.firstName||'') + ' ' + (p.lastName||'')).trim().toLowerCase() === name) || ((p.fullName||'') .toLowerCase() === name) || ((p.name||'').toLowerCase() === name)); if(found) return String(found.id); } }
          }catch(e){}
          return people.length ? String(people[0].id) : null;
        }

        const focusId = getFocusId(); if(!focusId) return { nodes: [], edges: [] };

        const nodesMap = new Map(); const edges = [];
        const parentMap = new Map(); // id -> [fatherId, motherId] (may include nulls)
        function addNode(p){ const id = String(p.id); if(!nodesMap.has(id)){
          const name = ((((p.firstName||'') + ' ' + (p.lastName||'')).trim()) || (p.name||''));

          function resolveDate(v){ try{
              if(v === undefined || v === null) return '';
              if(typeof v === 'string' || typeof v === 'number'){
                const s = String(v).trim(); return s;
              }
              if(Array.isArray(v)) return resolveDate(v[0]);
              if(typeof v === 'object'){
                const keys = ['date','value','original','text','when','iso','isoDate'];
                for(const k of keys) if(v[k]) return resolveDate(v[k]);
                for(const val of Object.values(v)){
                  const r = resolveDate(val); if(r) return r;
                }
              }
              return '';
            }catch(e){ return ''; } }

          function searchForDate(obj, patterns){ try{
              if(obj === undefined || obj === null) return '';
              if(typeof obj === 'string' || typeof obj === 'number') return '';
              if(Array.isArray(obj)){
                for(const it of obj){ const r = searchForDate(it, patterns); if(r) return r; }
                return '';
              }
              for(const k of Object.keys(obj)){
                const lower = k.toString().toLowerCase();
                for(const pat of patterns){ if(lower.includes(pat)){
                  const r = resolveDate(obj[k]); if(r) return r;
                } }
                const val = obj[k]; if(typeof val === 'object'){
                  const r = searchForDate(val, patterns); if(r) return r;
                }
              }
              return '';
            }catch(e){ return ''; } }

          const possibleBirth = p.birthDate || p.birth || p.dob || p.nasc || p.dataNascimento || p.dateOfBirth || '';
          const possibleDeath = p.deathDate || p.death || p.dod || p.obito || p.dataObito || '';
          // prefer events store (Árvore page uses events:BIRTH / events:DEATH)
          let b = '';
          let o = '';
          try{
            const evs = getEvents().filter(ev => ev && (String(ev.personId) === String(p.id) || String(ev.personId) === String(p.id + '')) && !ev.deletedAt);
            const birthEv = evs.find(e => (''+ (e.type||'')).toUpperCase() === 'BIRTH' || (''+ (e.type||'')).toUpperCase().includes('BIRTH'));
            const deathEv = evs.find(e => (''+ (e.type||'')).toUpperCase() === 'DEATH' || (''+ (e.type||'')).toUpperCase().includes('DEATH'));
            if(birthEv && (birthEv.date || birthEv.dates || birthEv.value)) b = resolveDate(birthEv.date || birthEv.value || birthEv.dates || '');
            if(deathEv && (deathEv.date || deathEv.dates || deathEv.value)) o = resolveDate(deathEv.date || deathEv.value || deathEv.dates || '');
          }catch(e){ /* ignore event parsing errors */ }
          // fallback to person fields / nested values
          if(!b) b = resolveDate(possibleBirth) || searchForDate(p, ['birth','birt','nasc','dob','nascimento']);
          if(!o) o = resolveDate(possibleDeath) || searchForDate(p, ['death','deat','obito','dod']);

          const lines = [name];
          if(b) lines.push('Nasc: ' + b);
          if(o) lines.push('Óbito: ' + o);
          const displayLabel = lines.join('\n');
          nodesMap.set(id, { data: { id, name, img: getThumbnailForPerson(p.id) || genderPlaceholder(p.gender), gender: p.gender || '', birth: b, death: o, displayLabel } });
        } }

        // helper: collect parent ids from different possible keys used in data
        function getParentIds(person){ if(!person) return []; const fatherCandidates = [person.fatherId, person.father, person.paiId]; const motherCandidates = [person.motherId, person.mother, person.maeId]; const father = fatherCandidates.find(x=>x!==undefined && x!==null); const mother = motherCandidates.find(x=>x!==undefined && x!==null); const list = []; if(father !== undefined && father !== null) list.push(String(father)); if(mother !== undefined && mother !== null) list.push(String(mother)); // preserve order: father then mother when available
          if(Array.isArray(person.parents)){
            // try to fill missing slots from generic parents array (best-effort)
            const extras = person.parents.filter(x => x!==undefined && x!==null).map(String);
            extras.forEach(x=>{ if(!list.includes(x)) list.push(x); });
          }
          // also check relations store for parent relations (fallback)
          try{
            const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]');
            rels.forEach(r => {
              if(!r) return;
              const from = r.from || r.personId || r.source || r.a || null;
              const to = r.to || r.targetId || r.target || r.b || null;
              const t = (r.type||'').toString().toLowerCase();
              // detect parent-like relation types
              if(!t) return;
              const isParentType = t.includes('parent') || t.includes('pai') || t.includes('mae') || t.includes('mother') || t.includes('father');
              if(!isParentType) return;
              try{
                if(String(from) === String(person.id) && to !== undefined && to !== null){ if(!list.includes(String(to))) list.push(String(to)); }
                else if(String(to) === String(person.id) && from !== undefined && from !== null){ if(!list.includes(String(from))) list.push(String(from)); }
              }catch(e){}
            });
          }catch(e){}
          // try to order as father then mother when possible using known genders
          if(list.length > 1){ const males = []; const females = []; const others = []; list.forEach(id => { const p = idMap.get(String(id)); const g = (p && p.gender) ? p.gender.toString().toLowerCase() : ''; if(g.startsWith('m')) males.push(id); else if(g.startsWith('f')) females.push(id); else others.push(id); }); const ordered = []; if(males.length) males.forEach(x=>{ if(!ordered.includes(x)) ordered.push(x); }); if(females.length) females.forEach(x=>{ if(!ordered.includes(x)) ordered.push(x); }); others.forEach(x=>{ if(!ordered.includes(x)) ordered.push(x); }); return ordered; }
          return list;
        }

        // helper: check nested structures for presence of id (robust fallback)
        function containsId(value, id, seen){ if(value == null) return false; if(seen === undefined) seen = new Set(); if(typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return String(value) === String(id); if(Array.isArray(value)) return value.some(v => containsId(v, id, seen)); if(typeof value === 'object'){ if(seen.has(value)) return false; seen.add(value); return Object.values(value).some(v => containsId(v, id, seen)); } return false; }

        // add root
        const root = idMap.get(focusId);
        if(!root) return { nodes: [], edges: [] };
        addNode(root);

        // ancestors: use same algorithm as arvore.html — consult relations:myLineage (types like 'ancestor'/'child')
        function addAncestors(person){ if(!person) return;
          // collect possible relations from relations store
          const targets = [];
          try{
            const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]');
            function normalizeType(t){ if(!t) return ''; return (''+t).toLowerCase(); }
            function invertType(t){ const n = normalizeType(t); if(n === 'ancestor') return 'child'; if(n === 'child') return 'ancestor'; return n; }
            const relsFrom = rels.filter(r => String(r.from) === String(person.id));
            const relsTo = rels.filter(r => String(r.to) === String(person.id));
            relsFrom.forEach(r => { if(r && (r.to !== undefined && r.to !== null)) targets.push({ id: r.to, type: normalizeType(r.type) }); });
            relsTo.forEach(r => { if(r && (r.from !== undefined && r.from !== null)) targets.push({ id: r.from, type: invertType(r.type) }); });
          }catch(e){}

          // also include explicit parent fields from the person record as 'ancestor'
          try{ const explicit = getParentIds(person); explicit.forEach(pid => { if(pid) targets.push({ id: pid, type: 'ancestor' }); }); }catch(e){}

          // unique by id, prefer explicit ancestor type when present
          const uniqueMap = new Map();
          targets.forEach(t => { if(!t || t.id === undefined || t.id === null) return; const key = String(t.id); const prev = uniqueMap.get(key); if(!prev) uniqueMap.set(key, t); else { // prefer ancestor type
              if((prev.type || '') !== 'ancestor' && (t.type || '') === 'ancestor') uniqueMap.set(key, t);
          } });
          const unique = Array.from(uniqueMap.values());
          // parents are those classified as 'ancestor'
          const parents = unique.filter(u => ((u.type||'') + '').toLowerCase() === 'ancestor').map(u => String(u.id));
          // fallback: if none found, use previous heuristic
          const finalParents = parents.length ? parents : getParentIds(person);

          parentMap.set(String(person.id), finalParents.slice());
          finalParents.forEach(pid=>{ if(!pid) return; const parent = idMap.get(String(pid)); if(parent){ addNode(parent); const g = (parent.gender||'').toString().toLowerCase(); const label = g.startsWith('f') ? 'Mãe' : g.startsWith('m') ? 'Pai' : 'Pai / Mãe'; const edgeId = `e_${String(pid)}_${person.id}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: String(pid), target: String(person.id), label } }); addAncestors(parent); } }); }
        addAncestors(root);
        // fallback: if some parents are referenced in nested fields of root, pick them as well
        try{
          people.forEach(p=>{ if(!p || String(p.id) === String(root.id)) return; if(containsId(root, p.id) && !nodesMap.has(String(p.id))){ addNode(p); const g=(p.gender||'').toString().toLowerCase(); const label = g.startsWith('f') ? 'Mãe' : g.startsWith('m') ? 'Pai' : 'Pai / Mãe'; const edgeId = `e_${String(p.id)}_${root.id}`; if(!edges.find(e=>e.data && e.data.id===edgeId)) edges.push({ data:{ id: edgeId, source: String(p.id), target: String(root.id), label } }); addAncestors(p); } });
        }catch(e){}

        // siblings: people sharing any parent id with root (using all parent keys)
        function addSiblings(person){ if(!person) return; const myParents = new Set(getParentIds(person)); people.forEach(p=>{ const pid = String(p.id); if(pid === String(person.id)) return; const theirParents = getParentIds(p); const shares = theirParents.some(x => myParents.has(String(x))); if(shares){ addNode(p); const g = (p.gender||'').toString().toLowerCase(); const sibLabel = (g==='female' || g==='feminino' || g==='f') ? 'Irmã' : (g==='male' || g==='masculino' || g==='m') ? 'Irmão' : 'Irmão / Irmã'; const edgeId = `e_sib_${person.id}_${pid}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: String(person.id), target: pid, label: sibLabel } }); } }); }
        addSiblings(root);

        // partner(s): check spouseId / partnerId and relations store
        const __partners_for_root = new Set();
        function addPartners(person){ if(!person) return; const partners = new Set(); if(person.spouseId) partners.add(String(person.spouseId)); if(person.partnerId) partners.add(String(person.partnerId)); // scan relations store for mate-like relations
          try{ const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]'); rels.forEach(r=>{ if(!r) return; const from = String(r.from||r.personId||''); const to = String(r.to||r.targetId||''); const t = (r.type||'').toString().toLowerCase(); if((from === String(person.id) && (t.includes('mate')||t.includes('spouse')||t.includes('compan')||t.includes('parceiro')||t.includes('conjuge'))) && to) partners.add(to); if((to === String(person.id) && (t.includes('mate')||t.includes('spouse')||t.includes('compan')||t.includes('parceiro')||t.includes('conjuge'))) && from) partners.add(from); }); }catch(e){}
          partners.forEach(pid=>{ const p = idMap.get(pid); if(p){ addNode(p); const g = (p.gender||'').toString().toLowerCase(); const label = (g==='female'||g==='feminino'||g==='f') ? 'Companheira' : (g==='male'||g==='masculino'||g==='m') ? 'Companheiro' : 'Companheiro(a)'; __partners_for_root.add(String(pid)); } }); }
        addPartners(root);

        // children: people where root is listed as a parent in any supported key
        function addChildren(person){ if(!person) return; const rootId = String(person.id); people.forEach(p=>{ const pid = String(p.id); const parentIds = getParentIds(p); if(parentIds.includes(rootId) || containsId(p, rootId)){ addNode(p); const g=(p.gender||'').toString().toLowerCase(); const label = (g==='female'||g==='feminino'||g==='f') ? 'Filha' : (g==='male'||g==='masculino'||g==='m') ? 'Filho' : 'Filho(a)'; const edgeId = `e_child_${person.id}_${pid}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: rootId, target: pid, label } }); } }); }
        addChildren(root);

        // Build positions for an ancestor-oriented layout (parents above). We'll compute a simple horizontal packing
        // preserve father then mother order using parentMap. We'll produce positions later in renderGraph via preset layout.

        // produce arrays
        const nodes = Array.from(nodesMap.values());
        return { nodes, edges, parentMap, rootId: String(root.id), partners: Array.from(__partners_for_root) };
      }

      // Render with Cytoscape using preset positions computed from ancestor tree
      let _cy = null;
      function renderGraph(){
        const data = buildGraphData();
        const container = document.getElementById('cy');
        container.innerHTML = '';
        if(_cy){ try{ _cy.destroy(); }catch(e){} _cy = null; }

        // compute tree positions
        const nodeWidth = 260; const nodeHeight = 150; const hGap = 40; const vGap = 160;
        // compute thumbnail and text layout inside each node so label doesn't overlap image
        const thumbWidth = Math.round(nodeWidth * 0.28); const thumbHeight = Math.round(nodeHeight * 0.8); const thumbLeft = 12; const textMaxWidthCalc = nodeWidth - thumbWidth - (thumbLeft + 18); const textMarginXCalc = thumbLeft + thumbWidth + 12;
        const parentMap = data.parentMap || new Map();
        const positions = new Map();
        const widths = new Map();
        const visited = new Set();

        function measure(id){ if(widths.has(id)) return widths.get(id); if(visited.has(id)){ widths.set(id, nodeWidth); return nodeWidth; } visited.add(id); const parents = parentMap.get(String(id)) || []; if(!parents || parents.length===0){ widths.set(id, nodeWidth); return nodeWidth; } let sum = 0; parents.forEach(pid=>{ if(!pid) return; if(!idMapHas(pid)) return; sum += measure(pid); }); if(sum === 0) sum = nodeWidth; widths.set(id, sum); return sum; }

        // helper to know if id exists in nodes
        const nodeIds = new Set((data.nodes||[]).map(n=>String(n.data.id)));
        function idMapHas(id){ return nodeIds.has(String(id)); }

        // measure all starting from root
        const rootId = data.rootId;
        if(rootId){ measure(rootId); }

        // compute depth (generation) where root is depth 0, parents depth 1, etc.
        const depthMemo = new Map();
        function getDepth(id){ if(depthMemo.has(id)) return depthMemo.get(id); const parents = parentMap.get(String(id)) || []; if(!parents || parents.length===0){ depthMemo.set(id, 0); return 0; } const d = 1 + Math.max(...parents.map(pid=> idMapHas(pid) ? getDepth(pid) : 0)); depthMemo.set(id, d); return d; }

        // place parents recursively and set positions
        function placeWithY(id, xStart){ const parents = parentMap.get(String(id)) || []; if(!parents || parents.length===0){ const w = widths.get(id) || nodeWidth; const x = xStart + w/2; const y = (getDepth(id) * vGap); positions.set(String(id), { x, y }); return { left: xStart, right: xStart + w }; }
          let curr = xStart; const centers = []; parents.forEach(pid=>{ if(!idMapHas(pid)) return; const pw = widths.get(pid) || nodeWidth; const r = placeWithY(pid, curr); const center = (r.left + r.right)/2; centers.push(center); curr = r.right + hGap; }); const myX = centers.length ? centers.reduce((a,b)=>a+b,0)/centers.length : xStart + (widths.get(id)||nodeWidth)/2; const y = (getDepth(id) * vGap); positions.set(String(id), { x: myX, y }); return { left: (centers.length ? Math.min(...centers) - (nodeWidth/2) : xStart), right: (centers.length ? Math.max(...centers) + (nodeWidth/2) : xStart + (widths.get(id)||nodeWidth)) } }

        if(rootId){ const total = widths.get(rootId) || nodeWidth; const startX = - (total/2); placeWithY(rootId, startX);
          // position partner(s) side-by-side at the same vertical level as root
          try{
            // place partners to the right of the focused person using the focused card width
            const partnerIds = (data.partners || []).filter(id => idMapHas(id));
            if(partnerIds.length){
              const rootPos = positions.get(String(rootId)) || { x: 0, y: 0 };
              // right edge of root center + half width
              const firstCenterX = rootPos.x + (nodeWidth / 2) + hGap + (nodeWidth / 2); // root right edge + gap + half partner
              for(let i = 0; i < partnerIds.length; i++){
                const pid = String(partnerIds[i]);
                const x = firstCenterX + i * (nodeWidth + hGap);
                positions.set(pid, { x: Math.round(x), y: Math.round(rootPos.y) });
              }
            }
          }catch(e){ /* ignore partner positioning errors */ }
        }

        // translate positions into node positions and default y for root if missing
        const positionedNodes = (data.nodes||[]).map(n=>{ const id = String(n.data.id); const pos = positions.get(id) || { x: 0, y: 0 }; return { data: n.data, position: { x: Math.round(pos.x), y: Math.round(pos.y) } }; });

        // helper to escape XML for embedding text inside SVG
        function escapeXml(unsafe){ if(!unsafe && unsafe !== 0) return ''; return String(unsafe).replace(/&/g, '&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

        // simple word-wrap: split text into lines that fit approx maxChars
        function wrapTextToLines(text, maxPx, fontSize){
          if(!text) return [''];
          const approxCharWidth = fontSize * 0.6; // rough estimate
          const maxChars = Math.max(8, Math.floor(maxPx / approxCharWidth));
          const words = String(text).split(/\s+/).filter(Boolean);
          const lines = [];
          let cur = '';
          for(const w of words){
            if((cur + (cur? ' ' : '') + w).length <= maxChars){ cur = cur ? (cur + ' ' + w) : w; }
            else { if(cur) lines.push(cur); cur = w; }
          }
          if(cur) lines.push(cur);
          return lines;
        }

        // Compose an SVG per-node that places the thumbnail on the left and name (wrapped) + birth + death on the right.
        positionedNodes.forEach(n => {
          const d = n.data || {};
          const imgUrl = d.img || '';
          const name = d.name || '';
          const birth = d.birth || '';
          const death = d.death || '';
          const fontSize = 14;
          const lineHeight = Math.round(fontSize * 1.25);
          const textX = textMarginXCalc;
          const topPadding = 18;
          const nameLines = wrapTextToLines(name, textMaxWidthCalc, fontSize);
          // limit name lines to max 3 to keep birth/death visible; if more, truncate
          const maxNameLines = 3;
          if(nameLines.length > maxNameLines){ nameLines.length = maxNameLines; nameLines[maxNameLines-1] = nameLines[maxNameLines-1] + '...'; }
          // compute y for name first line
          const nameStartY = topPadding + fontSize;
          // compute y for birth and death after name block
          const birthY = nameStartY + (nameLines.length * lineHeight) + 8;
          const deathY = birthY + lineHeight;
          const bg = '#9aa0a6';
          // build tspan elements for name
          const nameTspans = nameLines.map((ln, idx) => `<tspan x='${textX}' dy='${ idx===0 ? 0 : lineHeight }'>${escapeXml(ln)}</tspan>`).join('');
          const svg = `<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' width='${nodeWidth}' height='${nodeHeight}' viewBox='0 0 ${nodeWidth} ${nodeHeight}'>
            <rect rx='12' width='100%' height='100%' fill='${bg}' />
            <image href='${escapeXml(imgUrl)}' x='${thumbLeft}' y='${Math.round((nodeHeight - thumbHeight)/2)}' width='${thumbWidth}' height='${thumbHeight}' preserveAspectRatio='xMidYMid slice' />
            <g fill='#222' font-family='Arial, Helvetica, sans-serif' font-size='${fontSize}' text-anchor='start'>
              <text x='${textX}' y='${nameStartY}'>${nameTspans}</text>
              <text x='${textX}' y='${birthY}'>${escapeXml(birth ? ('Nasc: ' + birth) : '')}</text>
              <text x='${textX}' y='${deathY}'>${escapeXml(death ? ('Óbito: ' + death) : '')}</text>
            </g>
          </svg>`;
          try{ d.img = 'data:image/svg+xml;base64,' + base64EncodeUnicode(svg); }catch(e){ d.img = d.img; }
          // clear label so Cytoscape doesn't draw external text
          d.displayLabel = '';
        });

        // ensure edge labels are visible
        // create visual partner edges (do not include them in ancestor calculations)
        const partnerEdges = [];
        try{
          (data.partners || []).forEach(pid => {
            if(!idMapHas(pid)) return;
            const nodeInfo = (data.nodes||[]).find(n => String(n.data.id) === String(pid));
            const g = (nodeInfo && nodeInfo.data && nodeInfo.data.gender) ? String(nodeInfo.data.gender).toLowerCase() : '';
            const label = (g==='female'||g==='feminino'||g==='f') ? 'Companheira' : (g==='male'||g==='masculino'||g==='m') ? 'Companheiro' : 'Companheiro(a)';
            partnerEdges.push({ data: { id: `e_partner_${rootId}_${pid}`, source: String(rootId), target: String(pid), label, rel: 'partner' } });
          });
        }catch(e){}

        const cyElements = { nodes: positionedNodes, edges: (data.edges||[]).concat(partnerEdges) };

        _cy = cytoscape({
          container: container,
          elements: cyElements,
          style: [
            { selector: 'node', style: {
              'shape':'round-rectangle', 'width': nodeWidth, 'height': nodeHeight, 'background-image':'data(img)', 'background-fit':'cover', 'background-width':'100%', 'background-height':'100%', 'background-position-x':'50%', 'background-position-y':'50%', 'border-width':3,
              'label':'data(displayLabel)', 'text-valign':'top','text-halign':'left','text-wrap':'wrap','text-max-width': textMaxWidthCalc,'font-size':13,'color':'#222','text-margin-x': textMarginXCalc,'text-margin-y':12
            }},
            { selector: 'node[gender]', style: { 'border-color': function(ele){ const g = (ele.data('gender')||'').toString().toLowerCase(); return (g==='female'||g==='feminino'||g==='f') ? '#e26aa6' : (g==='male'||g==='masculino'||g==='m') ? '#4a90e2' : '#9aa0a6'; } }},
            { selector: 'edge', style: { 'width':2,'line-color':'#888','target-arrow-shape':'triangle','target-arrow-color':'#888','curve-style':'bezier','label':'data(label)','font-size':11,'text-rotation':'autorotate','text-margin-y':-6,'color':'#333' } },
            { selector: 'edge[rel = "partner"]', style: { 'line-style':'dashed','target-arrow-shape':'none','source-arrow-shape':'none' } }
          ],
          layout: { name: 'preset' }
        });

        _cy.on('tap', 'node', function(evt){ const id = evt.target.id(); window.location.href = `pessoa-detalhe.html?id=${encodeURIComponent(id)}`; });
        _cy.fit(40);
      }

      document.addEventListener('DOMContentLoaded', function(){
        renderGraph();
        // re-render on storage changes
        window.addEventListener('storage', function(){ try{ renderGraph(); }catch(e){} });
        // allow changing rank direction
        const rankSel = document.getElementById('rankDir'); if(rankSel) rankSel.addEventListener('change', ()=>renderGraph());
        // reset focus button
        const resetBtn = document.getElementById('resetFocusBtn'); if(resetBtn) resetBtn.addEventListener('click', ()=>{ location.reload(); });
      });
    </script>
  </body>
</html>
