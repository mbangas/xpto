<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>myLineage — Árvore Genealógica</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css">
    <!-- Cytoscape and dagre for hierarchical layout -->
    <script src="https://unpkg.com/cytoscape@3.24.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.3.2/cytoscape-dagre.js"></script>
    <style>
      #cy, #cy * { -webkit-user-select:none; user-select:none; }
    </style>
    <script src="remote-storage.js"></script>
  </head>
  <body class="page-tree">
    <div class="app-shell">
      <aside class="sidebar">
        <a href="index.html" class="logo"><i class="mdi mdi-tree" aria-hidden="true"></i><span>myLineage</span></a>
        <nav>
          <a href="app.html"><i class="mdi mdi-account-multiple" aria-hidden="true"></i>Cadastro</a>
          <a href="indicadores.html"><i class="mdi mdi-chart-bar" aria-hidden="true"></i>Indicadores</a>
          <a href="arvore.html" class="active"><i class="mdi mdi-sitemap" aria-hidden="true"></i>Árvore</a>
          <a href="gedcom.html"><i class="mdi mdi-dna" aria-hidden="true"></i>GEDCOM</a>
          <a href="album.html"><i class="mdi mdi-image-multiple" aria-hidden="true"></i>Álbum</a>
          <a href="documentos.html"><i class="mdi mdi-folder-open" aria-hidden="true"></i>Documentos</a>
        </nav>
        <div class="sidebar-footer">
          <a href="apis.html"><i class="mdi mdi-api" aria-hidden="true"></i>APIs</a>
          <a href="configuracao.html"><i class="mdi mdi-cog" aria-hidden="true"></i>Definições</a>
        </div>
      </aside>
      <main class="content">
        <div class="topbar">
          <div style="display:flex;align-items:center;gap:10px;">
            <i class="mdi mdi-sitemap" style="color:var(--accent);font-size:1.15rem;"></i>
            <h1>Árvore Genealógica</h1>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button id="addPersonTreeBtn" class="btn btn-sm" title="Adicionar nova pessoa">
              <i class="mdi mdi-plus" aria-hidden="true"></i> Nova Pessoa
            </button>
            <button id="resetFocusBtn" class="btn btn-ghost btn-sm" title="Resetar foco para a pessoa configurada">
              <i class="mdi mdi-crosshairs-gps" aria-hidden="true"></i> Reset foco
            </button>
          </div>
        </div>

        <div class="tree-canvas-wrap">
          <div id="cy" style="width:100%;position:relative;"></div>
          <div class="legend">
            <span><span class="avatar" style="background:#4493f8"></span> Masculino</span>
            <span><span class="avatar" style="background:#e26aa6"></span> Feminino</span>
            <span><span class="avatar" style="background:#9aa0a6"></span> Outro</span>
          </div>
        </div>

        <div id="person-focus" class="person-focus" aria-live="polite"></div>
      </main>
    </div>

    <!-- ── Right drawer overlay ── -->
    <div class="drawer-overlay" id="drawerOverlay"></div>

    <!-- ── Right drawer ── -->
    <div class="drawer" id="personDrawer" role="dialog" aria-modal="true" aria-labelledby="drawerTitle">
      <div class="drawer-header">
        <button class="btn btn-ghost btn-sm" id="drawerBackBtn" style="display:none;padding:2px 6px;margin-right:4px;" title="Voltar"><i class="mdi mdi-arrow-left"></i></button>
        <h2 id="drawerTitle" style="flex:1;">Detalhes da Pessoa</h2>
        <button class="drawer-close" id="drawerCloseBtn" aria-label="Fechar painel"><i class="mdi mdi-close"></i></button>
      </div>
      <!-- Person identity strip -->
      <div class="drawer-person-header" id="drawerPersonHeader">
        <div class="drawer-avatar" id="drawerAvatar"></div>
        <div>
          <div class="drawer-person-name" id="drawerPersonName">—</div>
          <div class="drawer-person-sub" id="drawerPersonSub"></div>
        </div>
        <div class="drawer-person-actions">
          <a id="drawerDetailLink" href="#" class="btn btn-ghost btn-sm" title="Abrir detalhe completo">
            <i class="mdi mdi-open-in-new"></i>
          </a>
        </div>
      </div>
      <div class="drawer-body" id="drawerBody">
        <!-- injected by JS -->
      </div>
      <div class="drawer-footer">
        <button class="btn btn-danger btn-sm" id="drawerDeleteBtn"><i class="mdi mdi-delete-outline"></i> Apagar</button>
        <button class="btn btn-ghost btn-sm" id="drawerCancelBtn">Cancelar</button>
        <button class="btn btn-sm" id="drawerSaveBtn"><i class="mdi mdi-content-save-outline"></i> Guardar</button>
      </div>
    </div>

    <!-- ── Drawer photo lightbox ── -->
    <div id="drawerPhotoLightbox" style="display:none;position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.82);align-items:center;justify-content:center;z-index:600;" onclick="this.style.display='none';">
      <img id="drawerPhotoLightboxImg" src="" style="max-width:92vw;max-height:92vh;object-fit:contain;border-radius:8px;box-shadow:0 8px 32px rgba(0,0,0,0.6);" />
    </div>

    <script>
      // Helpers (localStorage-backed data)
      function getPeople(){ try{ const raw = localStorage.getItem('people:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function getPhotos(){ try{ const raw = localStorage.getItem('photos:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function getPhotoRelations(){ try{ const raw = localStorage.getItem('photoRelations:myLineage'); return raw ? JSON.parse(raw) : {}; }catch(e){ return {}; } }
      function getEvents(){ try{ const raw = localStorage.getItem('events:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function genderPlaceholder(g){
        const gender = (g||'').toString().toLowerCase();
        const color = (gender==='female' || gender==='feminino' || gender==='f') ? '#e26aa6' : (gender==='male' || gender==='masculino' || gender==='m') ? '#4a90e2' : '#9aa0a6';
        // simple silhouette on colored rounded rect background
        const svg = `<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 120 120'>
          <rect width='100%' height='100%' fill='${color}' rx='12'/>
          <g fill='#ffffff' transform='translate(30,20)'>
            <circle cx='30' cy='24' r='16'/>
            <path d='M6 80c0-18 36-18 48-18s48 0 48 18v6H6v-6z' />
          </g>
        </svg>`;
        return 'data:image/svg+xml;base64,' + base64EncodeUnicode(svg);
      }
      // base64 encode supporting Unicode characters
      function base64EncodeUnicode(str) {
        try{
          return btoa(unescape(encodeURIComponent(str)));
        }catch(e){
          // fallback to plain btoa if above fails
          return btoa(str);
        }
      }
      function getThumbnailForPerson(personId){ try{ const rels = getPhotoRelations(); const photos = getPhotos(); const ids = rels[personId] || []; if(Array.isArray(ids) && ids.length){ for(const id of ids){ const ph = photos.find(p=>String(p.id)===String(id)); if(ph){ return ph.originalDataUrl || ph.dataUrl || null; } } } return null; }catch(e){ return null; } }

      

      // ensure RuntimeFocus exists on window for compatibility
      window.RuntimeFocus = window.RuntimeFocus || null;

      // Helper: check if a partner edge between two node ids already exists in an array
      function partnerEdgeExists(arr, idA, idB){
        return arr.some(function(e){
          if(!e || !e.data) return false;
          const s = String(e.data.source||''); const t = String(e.data.target||'');
          return (s===String(idA)&&t===String(idB)) || (s===String(idB)&&t===String(idA));
        });
      }

      // Build a focused subgraph: focused person -> ancestors (upwards), siblings, partner(s), children
      function buildGraphData(){
        const people = getPeople().filter(p=>!p.deletedAt);
        const idMap = new Map(people.map(p=>[String(p.id), p]));
        // determine focus id: RuntimeFocus if set, otherwise persisted focus, otherwise first person
        function getFocusId(){
          if(window.RuntimeFocus && window.RuntimeFocus.id) return String(window.RuntimeFocus.id);
          try{
            const saved = JSON.parse(localStorage.getItem('focusedPerson:myLineage') || 'null');
            if(saved){ if(saved.id) return String(saved.id); if(saved.name){ const name = (saved.name||'').trim().toLowerCase(); const found = people.find(p => (((p.firstName||'') + ' ' + (p.lastName||'')).trim().toLowerCase() === name) || ((p.fullName||'') .toLowerCase() === name) || ((p.name||'').toLowerCase() === name)); if(found) return String(found.id); } }
          }catch(e){}
          return people.length ? String(people[0].id) : null;
        }

        const focusId = getFocusId(); if(!focusId) return { nodes: [], edges: [] };

        const nodesMap = new Map(); const edges = [];
        const parentMap = new Map(); // id -> [fatherId, motherId] (may include nulls)
        function addNode(p){ const id = String(p.id); if(!nodesMap.has(id)){
          const name = ((((p.firstName||'') + ' ' + (p.lastName||'')).trim()) || (p.name||''));

          function resolveDate(v){ try{
              if(v === undefined || v === null) return '';
              if(typeof v === 'string' || typeof v === 'number'){
                const s = String(v).trim(); return s;
              }
              if(Array.isArray(v)) return resolveDate(v[0]);
              if(typeof v === 'object'){
                const keys = ['date','value','original','text','when','iso','isoDate'];
                for(const k of keys) if(v[k]) return resolveDate(v[k]);
                for(const val of Object.values(v)){
                  const r = resolveDate(val); if(r) return r;
                }
              }
              return '';
            }catch(e){ return ''; } }

          function searchForDate(obj, patterns){ try{
              if(obj === undefined || obj === null) return '';
              if(typeof obj === 'string' || typeof obj === 'number') return '';
              if(Array.isArray(obj)){
                for(const it of obj){ const r = searchForDate(it, patterns); if(r) return r; }
                return '';
              }
              for(const k of Object.keys(obj)){
                const lower = k.toString().toLowerCase();
                for(const pat of patterns){ if(lower.includes(pat)){
                  const r = resolveDate(obj[k]); if(r) return r;
                } }
                const val = obj[k]; if(typeof val === 'object'){
                  const r = searchForDate(val, patterns); if(r) return r;
                }
              }
              return '';
            }catch(e){ return ''; } }

          const possibleBirth = p.birthDate || p.birth || p.dob || p.nasc || p.dataNascimento || p.dateOfBirth || '';
          const possibleDeath = p.deathDate || p.death || p.dod || p.obito || p.dataObito || '';
          // prefer events store (Árvore page uses events:BIRTH / events:DEATH)
          let b = '';
          let o = '';
          try{
            const evs = getEvents().filter(ev => ev && (String(ev.personId) === String(p.id) || String(ev.personId) === String(p.id + '')) && !ev.deletedAt);
            const birthEv = evs.find(e => (''+ (e.type||'')).toUpperCase() === 'BIRTH' || (''+ (e.type||'')).toUpperCase().includes('BIRTH'));
            const deathEv = evs.find(e => (''+ (e.type||'')).toUpperCase() === 'DEATH' || (''+ (e.type||'')).toUpperCase().includes('DEATH'));
            if(birthEv && (birthEv.date || birthEv.dates || birthEv.value)) b = resolveDate(birthEv.date || birthEv.value || birthEv.dates || '');
            if(deathEv && (deathEv.date || deathEv.dates || deathEv.value)) o = resolveDate(deathEv.date || deathEv.value || deathEv.dates || '');
          }catch(e){ /* ignore event parsing errors */ }
          // fallback to person fields / nested values
          if(!b) b = resolveDate(possibleBirth) || searchForDate(p, ['birth','birt','nasc','dob','nascimento']);
          if(!o) o = resolveDate(possibleDeath) || searchForDate(p, ['death','deat','obito','dod']);

          const lines = [name];
          if(b) lines.push('Nasc: ' + b);
          if(o) lines.push('Óbito: ' + o);
          const displayLabel = lines.join('\n');
          nodesMap.set(id, { data: { id, name, img: getThumbnailForPerson(p.id) || genderPlaceholder(p.gender), gender: p.gender || '', birth: b, death: o, displayLabel } });
        } }

        // helper: collect parent ids from different possible keys used in data
        function getParentIds(person){ if(!person) return []; const fatherCandidates = [person.fatherId, person.father, person.paiId]; const motherCandidates = [person.motherId, person.mother, person.maeId]; const father = fatherCandidates.find(x=>x!==undefined && x!==null); const mother = motherCandidates.find(x=>x!==undefined && x!==null); const list = []; if(father !== undefined && father !== null) list.push(String(father)); if(mother !== undefined && mother !== null) list.push(String(mother)); // preserve order: father then mother when available
          if(Array.isArray(person.parents)){
            // try to fill missing slots from generic parents array (best-effort)
            const extras = person.parents.filter(x => x!==undefined && x!==null).map(String);
            extras.forEach(x=>{ if(!list.includes(x)) list.push(x); });
          }
          // also check relations store for parent relations (fallback)
          try{
            const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]');
            rels.forEach(r => {
              if(!r) return;
              const from = r.from || r.personId || r.source || r.a || null;
              const to = r.to || r.targetId || r.target || r.b || null;
              const t = (r.type||'').toString().toLowerCase();
              // detect parent-like relation types
              if(!t) return;
              const isParentType = t.includes('parent') || t.includes('pai') || t.includes('mae') || t.includes('mother') || t.includes('father');
              if(!isParentType) return;
              try{
                if(String(from) === String(person.id) && to !== undefined && to !== null){ if(!list.includes(String(to))) list.push(String(to)); }
                else if(String(to) === String(person.id) && from !== undefined && from !== null){ if(!list.includes(String(from))) list.push(String(from)); }
              }catch(e){}
            });
          }catch(e){}
          // try to order as father then mother when possible using known genders
          if(list.length > 1){ const males = []; const females = []; const others = []; list.forEach(id => { const p = idMap.get(String(id)); const g = (p && p.gender) ? p.gender.toString().toLowerCase() : ''; if(g.startsWith('m')) males.push(id); else if(g.startsWith('f')) females.push(id); else others.push(id); }); const ordered = []; if(males.length) males.forEach(x=>{ if(!ordered.includes(x)) ordered.push(x); }); if(females.length) females.forEach(x=>{ if(!ordered.includes(x)) ordered.push(x); }); others.forEach(x=>{ if(!ordered.includes(x)) ordered.push(x); }); return ordered; }
          return list;
        }

        // helper: check nested structures for presence of id (robust fallback)
        function containsId(value, id, seen){ if(value == null) return false; if(seen === undefined) seen = new Set(); if(typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return String(value) === String(id); if(Array.isArray(value)) return value.some(v => containsId(v, id, seen)); if(typeof value === 'object'){ if(seen.has(value)) return false; seen.add(value); return Object.values(value).some(v => containsId(v, id, seen)); } return false; }

        // add root
        const root = idMap.get(focusId);
        if(!root) return { nodes: [], edges: [] };
        addNode(root);

        // ancestors: use same algorithm as arvore.html — consult relations:myLineage (types like 'ancestor'/'child')
        function addAncestors(person){ if(!person) return;
          // collect possible relations from relations store
          const targets = [];
          try{
            const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]');
            function normalizeType(t){ if(!t) return ''; return (''+t).toLowerCase(); }
            function invertType(t){ const n = normalizeType(t); if(n === 'ancestor') return 'child'; if(n === 'child') return 'ancestor'; return n; }
            const relsFrom = rels.filter(r => String(r.from) === String(person.id));
            const relsTo = rels.filter(r => String(r.to) === String(person.id));
            relsFrom.forEach(r => { if(r && (r.to !== undefined && r.to !== null)) targets.push({ id: r.to, type: normalizeType(r.type) }); });
            relsTo.forEach(r => { if(r && (r.from !== undefined && r.from !== null)) targets.push({ id: r.from, type: invertType(r.type) }); });
          }catch(e){}

          // also include explicit parent fields from the person record as 'ancestor'
          try{ const explicit = getParentIds(person); explicit.forEach(pid => { if(pid) targets.push({ id: pid, type: 'ancestor' }); }); }catch(e){}

          // unique by id, prefer explicit ancestor type when present
          const uniqueMap = new Map();
          targets.forEach(t => { if(!t || t.id === undefined || t.id === null) return; const key = String(t.id); const prev = uniqueMap.get(key); if(!prev) uniqueMap.set(key, t); else { // prefer ancestor type
              if((prev.type || '') !== 'ancestor' && (t.type || '') === 'ancestor') uniqueMap.set(key, t);
          } });
          const unique = Array.from(uniqueMap.values());
          // parents are those classified as 'ancestor'
          const parents = unique.filter(u => ((u.type||'') + '').toLowerCase() === 'ancestor').map(u => String(u.id));
          // fallback: if none found, use previous heuristic
          const finalParents = parents.length ? parents : getParentIds(person);

          parentMap.set(String(person.id), finalParents.slice());
          finalParents.forEach(pid=>{ if(!pid) return; const parent = idMap.get(String(pid)); if(parent){ addNode(parent); addAncestors(parent); } }); }
        addAncestors(root);
        // fallback: if some parents are referenced in nested fields of root, pick them as well
        try{
          people.forEach(p=>{ if(!p || String(p.id) === String(root.id)) return; if(containsId(root, p.id) && !nodesMap.has(String(p.id))){ addNode(p); addAncestors(p); } });
        }catch(e){}

        // siblings: people sharing any parent id with root (using all parent keys)
        function addSiblings(person){ if(!person) return; const myParents = new Set(getParentIds(person)); people.forEach(p=>{ const pid = String(p.id); if(pid === String(person.id)) return; const theirParents = getParentIds(p); const shares = theirParents.some(x => myParents.has(String(x))); if(shares){ addNode(p); const g = (p.gender||'').toString().toLowerCase(); const sibLabel = (g==='female' || g==='feminino' || g==='f') ? 'Irmã' : (g==='male' || g==='masculino' || g==='m') ? 'Irmão' : 'Irmão / Irmã'; const edgeId = `e_sib_${person.id}_${pid}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: String(person.id), target: pid, label: sibLabel } }); } }); }
        addSiblings(root);

        // partner(s): check spouseId / partnerId and relations store
        const __partners_for_root = new Set();
        function addPartners(person){ if(!person) return; const partners = new Set(); if(person.spouseId) partners.add(String(person.spouseId)); if(person.partnerId) partners.add(String(person.partnerId)); // scan relations store for mate-like relations
          try{ const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]'); rels.forEach(r=>{ if(!r) return; const from = String(r.from||r.personId||''); const to = String(r.to||r.targetId||''); const t = (r.type||'').toString().toLowerCase(); if((from === String(person.id) && (t.includes('mate')||t.includes('spouse')||t.includes('compan')||t.includes('parceiro')||t.includes('conjuge'))) && to) partners.add(to); if((to === String(person.id) && (t.includes('mate')||t.includes('spouse')||t.includes('compan')||t.includes('parceiro')||t.includes('conjuge'))) && from) partners.add(from); }); }catch(e){}
          partners.forEach(pid=>{ const p = idMap.get(pid); if(p){ addNode(p); const g = (p.gender||'').toString().toLowerCase(); const label = (g==='female'||g==='feminino'||g==='f') ? 'Companheira' : (g==='male'||g==='masculino'||g==='m') ? 'Companheiro' : 'Companheiro(a)'; __partners_for_root.add(String(pid)); } }); }
        addPartners(root);

        // children: people where root is listed as a parent in any supported key
        // Enhanced to consult relations:myLineage (type 'ancestor') and the computed parentMap
        function addChildren(person){
          if(!person) return;
          const rootId = String(person.id);
          const childrenSet = new Set();

          // 1) consult relations store for 'ancestor' relations where 'to' = focused person
          // A relation { type:'ancestor', from: X, to: rootId } means rootId is an ancestor of X -> X is a child
          try{
            const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]');
            rels.forEach(r => {
              if(!r) return;
              const t = (r.type || '').toString().toLowerCase();
              const from = r.from || r.personId || r.a || null;
              const to = r.to || r.targetId || r.b || null;
              if(!from || !to) return;
              if(t === 'ancestor' && String(to) === rootId) childrenSet.add(String(from));
            });
          }catch(e){}

          // 2) scan explicit parent fields on people (fallback for data without relations store)
          people.forEach(p => {
            try{
              const pid = String(p.id);
              if(pid === rootId) return;
              const parentIds = getParentIds(p) || [];
              if(parentIds.map(String).includes(rootId)) childrenSet.add(pid);
            }catch(e){}
          });

          // 3) consult already computed parentMap (childId -> [parentIds])
          try{
            if(parentMap){
              for(const [childId, parents] of parentMap.entries()){
                if(!parents) continue;
                if(parents.map(String).includes(rootId)) childrenSet.add(String(childId));
              }
            }
          }catch(e){}

          // For each child: add the node, find ALL their parents (root + others),
          // add the other parent(s) as nodes, and populate parentMap so junction nodes can be created.
          const allRels = (() => { try{ return JSON.parse(localStorage.getItem('relations:myLineage') || '[]'); }catch(e){ return []; } })();

          // Helper: extract a sortable birth year (or Infinity if unknown) for ordering children oldest→youngest
          function getChildBirthSortKey(p){
            try{
              const evs = getEvents().filter(ev => ev && String(ev.personId) === String(p.id) && !ev.deletedAt);
              const birthEv = evs.find(e => (''+(e.type||'')).toUpperCase().includes('BIRTH'));
              if(birthEv){
                const raw = String(birthEv.date || birthEv.value || birthEv.dates || '').trim();
                if(raw){ const m = raw.match(/\d{3,4}/); if(m) return parseInt(m[0], 10); }
              }
              const fields = [p.birthDate, p.birth, p.dob, p.nasc, p.dataNascimento, p.dateOfBirth];
              for(const f of fields){ if(f){ const m = String(f).match(/\d{3,4}/); if(m) return parseInt(m[0], 10); } }
            }catch(e){}
            return Infinity;
          }

          // Sort children oldest→youngest before adding
          const sortedChildren = Array.from(childrenSet).sort((a, b) => {
            const pa = people.find(it => String(it.id) === String(a));
            const pb = people.find(it => String(it.id) === String(b));
            return getChildBirthSortKey(pa || {}) - getChildBirthSortKey(pb || {});
          });

          sortedChildren.forEach(pid => {
            if(pid === rootId) return;
            const p = people.find(it => String(it.id) === String(pid));
            if(!p) return;
            addNode(p);

            // Collect all parents of this child
            const childParentsSet = new Set([rootId]);

            // from relations: { type:'ancestor', from: pid, to: parentId }
            allRels.forEach(r => {
              if(!r) return;
              const t = (r.type || '').toString().toLowerCase();
              const from = r.from || r.personId || r.a || null;
              const to = r.to || r.targetId || r.b || null;
              if(!from || !to) return;
              if(t === 'ancestor' && String(from) === String(pid)) childParentsSet.add(String(to));
            });

            // from explicit person fields
            const explicitParents = getParentIds(p) || [];
            explicitParents.forEach(epid => { if(epid) childParentsSet.add(String(epid)); });

            // Add other parent nodes
            childParentsSet.forEach(parentId => {
              if(String(parentId) !== rootId) {
                const parentPerson = idMap.get(String(parentId));
                if(parentPerson) addNode(parentPerson);
              }
            });

            // Populate parentMap for this child (enables junction node creation)
            if(!parentMap.has(String(pid))) {
              const parentsList = Array.from(childParentsSet);
              // order: males first, then females, then others
              if(parentsList.length > 1){
                const males = [], females = [], others = [];
                parentsList.forEach(id => {
                  const pp = idMap.get(String(id));
                  const g = (pp && pp.gender) ? pp.gender.toString().toLowerCase() : '';
                  if(g.startsWith('m')) males.push(id);
                  else if(g.startsWith('f')) females.push(id);
                  else others.push(id);
                });
                parentMap.set(String(pid), [...males, ...females, ...others]);
              } else {
                parentMap.set(String(pid), parentsList);
              }
            }

            const g = (p.gender||'').toString().toLowerCase();
            const label = (g==='female'||g==='feminino'||g==='f') ? 'Filha' : (g==='male'||g==='masculino'||g==='m') ? 'Filho' : 'Filho(a)';
            const edgeId = `e_child_${person.id}_${pid}`;
            if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: rootId, target: pid, label } });
          });
        }

        addChildren(root);

        // Build positions for an ancestor-oriented layout (parents above). We'll compute a simple horizontal packing
        // preserve father then mother order using parentMap. We'll produce positions later in renderGraph via preset layout.

        // produce arrays
        const nodes = Array.from(nodesMap.values());
        return { nodes, edges, parentMap, rootId: String(root.id), partners: Array.from(__partners_for_root) };
      }

      // Render with Cytoscape using preset positions computed from ancestor tree
      let _cy = null;
      function renderGraph(){
        const data = buildGraphData();
        const container = document.getElementById('cy');
        container.innerHTML = '';
        if(_cy){ try{ _cy.destroy(); }catch(e){} _cy = null; }

        // ── Geometry constants ────────────────────────────────────────────────
        const nodeWidth = 220;
        const nodeHeight = 140;
        const hGap = 30;           // min horizontal gap between nodes
        const partnerGap = 50;     // gap between partners on the same row
        const rowHeight = nodeHeight + 180; // full row height (320px) between generations

        // thumbnail/text metrics (used also in SVG composition below)
        const thumbWidth = Math.round(nodeWidth * 0.28);
        const thumbHeight = Math.round(nodeHeight * 0.8);
        const thumbLeft = 12;
        const textMaxWidthCalc = nodeWidth - thumbWidth - (thumbLeft + 18);
        const textMarginXCalc = thumbLeft + thumbWidth + 12;

        const parentMap = data.parentMap || new Map();
        const positions = new Map();

        // helper: is this id a real person node (not a junction placeholder)?
        const nodeIds = new Set((data.nodes||[]).map(n => String(n.data.id)));
        function idMapHas(id){ return nodeIds.has(String(id)); }

        const rootId = data.rootId;

        // ── Build a childMap (parentId → [childIds]) from parentMap ──────────
        const childMap = new Map();
        for(const [cid, pars] of parentMap.entries()){
          (pars||[]).forEach(pid => {
            if(!pid) return;
            const k = String(pid);
            if(!childMap.has(k)) childMap.set(k, []);
            const arr = childMap.get(k);
            if(!arr.includes(String(cid))) arr.push(String(cid));
          });
        }

        // ── Compute levels above root (BFS upward from root through parentMap) ──
        // root = level 0, root's parents = level 1, grandparents = level 2, etc.
        const ancestorLevel = new Map();
        ancestorLevel.set(rootId, 0);
        (function bfsUp(id, level){
          (parentMap.get(String(id)) || []).filter(p => idMapHas(p)).forEach(pid => {
            const prev = ancestorLevel.get(String(pid));
            if(prev === undefined || prev < level + 1){
              ancestorLevel.set(String(pid), level + 1);
              bfsUp(pid, level + 1);
            }
          });
        })(rootId, 0);

        // ── Subtree-width measurement (for ancestor X placement) ──────────────
        const widths = new Map();
        const widthVisited = new Set();
        function measure(id){
          if(widths.has(id)) return widths.get(id);
          if(widthVisited.has(id)){ widths.set(id, nodeWidth); return nodeWidth; }
          widthVisited.add(id);
          const pars = (parentMap.get(String(id)) || []).filter(p => idMapHas(p));
          if(!pars.length){ widths.set(id, nodeWidth); return nodeWidth; }
          let sum = pars.reduce((s, p) => s + measure(String(p)), 0) + (pars.length - 1) * partnerGap;
          sum = Math.max(sum, nodeWidth);
          widths.set(id, sum);
          return sum;
        }

        // ── Place ancestors recursively ───────────────────────────────────────
        // Y = -(levelsAboveRoot) * rowHeight  →  ancestors go UPWARD (negative Y)
        function placeAncestors(id, xStart){
          const pars = (parentMap.get(String(id)) || []).filter(p => idMapHas(p));
          const level = ancestorLevel.get(String(id)) || 0;
          const y = -level * rowHeight;   // root=0, parents=-rowHeight, grandparents=-2*rowHeight

          if(!pars.length){
            const w = widths.get(String(id)) || nodeWidth;
            positions.set(String(id), { x: Math.round(xStart + w / 2), y });
            return { left: xStart, right: xStart + w };
          }

          let curr = xStart;
          const centers = [];
          const gap = pars.length === 2 ? partnerGap : hGap;
          pars.forEach(pid => {
            const r = placeAncestors(String(pid), curr);
            centers.push((r.left + r.right) / 2);
            curr = r.right + gap;
          });
          const myX = centers.reduce((a, b) => a + b, 0) / centers.length;
          positions.set(String(id), { x: Math.round(myX), y });
          return {
            left: Math.min(...centers) - nodeWidth / 2,
            right: Math.max(...centers) + nodeWidth / 2
          };
        }

        if(rootId){
          measure(rootId);
          const total = widths.get(rootId) || nodeWidth;
          placeAncestors(rootId, -total / 2);

          const rootPos = positions.get(rootId) || { x: 0, y: 0 };

          // ── Partners: placed to the right of root at root's Y ──────────────
          const partnerIds = (data.partners || []).filter(id => idMapHas(id));
          partnerIds.forEach((pid, i) => {
            const x = rootPos.x + nodeWidth / 2 + partnerGap + nodeWidth / 2 + i * (nodeWidth + partnerGap);
            positions.set(pid, { x: Math.round(x), y: rootPos.y });
          });

          // ── Co-parents: other parents of root's children, placed right of partners ──
          const coParents = [];
          for(const [, pars] of parentMap.entries()){
            if(!pars || pars.length < 2) continue;
            pars.forEach(pid => {
              const s = String(pid);
              if(s === rootId || positions.has(s) || !idMapHas(s)) return;
              if(!coParents.includes(s)) coParents.push(s);
            });
          }
          let rightmost = rootPos.x + nodeWidth / 2;
          for(const [, pos] of positions.entries()){
            if(Math.abs(pos.y - rootPos.y) < 10) rightmost = Math.max(rightmost, pos.x + nodeWidth / 2);
          }
          coParents.forEach((pid, idx) => {
            const x = rightmost + partnerGap + nodeWidth / 2 + idx * (nodeWidth + partnerGap);
            positions.set(pid, { x: Math.round(x), y: rootPos.y });
          });

          // ── Descendant BFS to get generation distance from root ────────────
          const descendantDist = new Map();
          {
            const q = [rootId];
            const seen = new Set([rootId]);
            let qi = 0;
            while(qi < q.length){
              const cur = q[qi++];
              (childMap.get(String(cur)) || []).forEach(k => {
                if(!seen.has(k) && idMapHas(k)){
                  seen.add(k);
                  descendantDist.set(k, (descendantDist.get(cur) || 0) + 1);
                  q.push(k);
                }
              });
            }
          }

          // ── Position children: ONE junction per parent pair, spread under it ─
          // Process generation by generation so parents are placed before their children
          const maxGen = descendantDist.size ? Math.max(...descendantDist.values()) : 0;
          for(let gen = 1; gen <= maxGen; gen++){
            // Group children of this generation by their parent pair
            const pairGroups = new Map(); // pairKey → { parents[], children[] }
            for(const [cid, pars] of parentMap.entries()){
              if(descendantDist.get(String(cid)) !== gen) continue;
              if(!idMapHas(String(cid))) continue;
              const validPars = (pars||[]).map(String).filter(p => idMapHas(p));
              if(!validPars.length) continue;
              const pairKey = [...validPars].sort().join('__');
              if(!pairGroups.has(pairKey)) pairGroups.set(pairKey, { parents: validPars, children: [] });
              pairGroups.get(pairKey).children.push(String(cid));
            }
            // Place each group's children centered under their parents' midpoint
            for(const [, group] of pairGroups.entries()){
              const pPos = group.parents.map(p => positions.get(p)).filter(Boolean);
              if(!pPos.length) continue;
              const jx = Math.round(pPos.reduce((s, p) => s + p.x, 0) / pPos.length);
              const jy = Math.round(pPos.reduce((s, p) => s + p.y, 0) / pPos.length);
              const slot = nodeWidth + hGap * 2;
              const n = group.children.length;
              const startX = Math.round(jx - (n - 1) * slot / 2);
              group.children.forEach((cid, idx) => {
                positions.set(cid, { x: startX + idx * slot, y: jy + rowHeight });
              });
            }
          }
        }

        // ── Overlap resolution per row ─────────────────────────────────────────
        {
          const minSpacing = nodeWidth + hGap;
          const yTol = 20;
          const yBuckets = new Map();
          for(const [id, pos] of positions.entries()){
            if(!idMapHas(String(id))) continue;
            const yKey = Math.round(pos.y / yTol) * yTol;
            if(!yBuckets.has(yKey)) yBuckets.set(yKey, []);
            yBuckets.get(yKey).push(String(id));
          }
          for(const [, ids] of yBuckets.entries()){
            if(ids.length < 2) continue;
            ids.sort((a, b) => (positions.get(a)||{x:0}).x - (positions.get(b)||{x:0}).x);
            let needs = false;
            for(let i = 1; i < ids.length; i++){
              if((positions.get(ids[i])||{x:0}).x - (positions.get(ids[i-1])||{x:0}).x < minSpacing){ needs = true; break; }
            }
            if(!needs) continue;
            const cx = Math.round(ids.reduce((s, id) => s + (positions.get(id)||{x:0}).x, 0) / ids.length);
            const sx = cx - Math.round((ids.length - 1) * minSpacing / 2);
            ids.forEach((id, i) => {
              const p = positions.get(id);
              if(p) positions.set(id, { x: sx + i * minSpacing, y: p.y });
            });
          }
        }

        // ── Build positionedNodes ─────────────────────────────────────────────
        const positionedNodes = (data.nodes||[]).map(n => {
          const id = String(n.data.id);
          const pos = positions.get(id) || { x: 0, y: 0 };
          return { data: n.data, position: { x: Math.round(pos.x), y: Math.round(pos.y) } };
        });

        // ── SVG node composition (thumbnail left, text right) ─────────────────
        function escapeXml(unsafe){ if(!unsafe && unsafe !== 0) return ''; return String(unsafe).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
        function wrapTextToLines(text, maxPx, fontSize){ if(!text) return ['']; const approxCharWidth = fontSize * 0.6; const maxChars = Math.max(8, Math.floor(maxPx / approxCharWidth)); const words = String(text).split(/\s+/).filter(Boolean); const lines = []; let cur = ''; for(const w of words){ if((cur + (cur? ' ' : '') + w).length <= maxChars){ cur = cur ? (cur + ' ' + w) : w; } else { if(cur) lines.push(cur); cur = w; } } if(cur) lines.push(cur); return lines; }

        positionedNodes.forEach(n => {
          const d = n.data || {};
          if(!d.name) return; // skip junction placeholder nodes
          const imgUrl = d.img || '';
          const name = d.name || '';
          const birth = d.birth || '';
          const death = d.death || '';
          const fontSize = 13;
          const lineHeight = Math.round(fontSize * 1.3);
          const textX = textMarginXCalc;
          const topPadding = 16;
          const nameLines = wrapTextToLines(name, textMaxWidthCalc, fontSize);
          const maxNameLines = 3;
          if(nameLines.length > maxNameLines){ nameLines.length = maxNameLines; nameLines[maxNameLines-1] = nameLines[maxNameLines-1] + '…'; }
          const nameStartY = topPadding + fontSize;
          const birthY = nameStartY + nameLines.length * lineHeight + 6;
          const deathY = birthY + lineHeight;
          const bg = '#9aa0a6';
          const nameTspans = nameLines.map((ln, idx) => `<tspan x='${textX}' dy='${idx===0 ? 0 : lineHeight}'>${escapeXml(ln)}</tspan>`).join('');
          const ribbonSvg = death ? `<polygon points='0,0 34,0 0,34' fill='#111'/>` : '';
          const svg = `<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' width='${nodeWidth}' height='${nodeHeight}' viewBox='0 0 ${nodeWidth} ${nodeHeight}'><rect rx='10' width='100%' height='100%' fill='${bg}'/>${ribbonSvg}<image href='${escapeXml(imgUrl)}' x='${thumbLeft}' y='${Math.round((nodeHeight-thumbHeight)/2)}' width='${thumbWidth}' height='${thumbHeight}' preserveAspectRatio='xMidYMid slice'/><g fill='#222' font-family='Arial,Helvetica,sans-serif' font-size='${fontSize}' text-anchor='start'><text x='${textX}' y='${nameStartY}'>${nameTspans}</text><text x='${textX}' y='${birthY}'>${escapeXml(birth ? 'Nasc: '+birth : '')}</text><text x='${textX}' y='${deathY}'>${escapeXml(death ? 'Óbito: '+death : '')}</text></g></svg>`;
          try{ d.img = 'data:image/svg+xml;base64,' + base64EncodeUnicode(svg); }catch(e){}
          d.displayLabel = '';
        });

        // ── Partner edges (dashed horizontal lines) ───────────────────────────
        const partnerEdges = [];
        // root ↔ partner(s)
        (data.partners || []).forEach(pid => {
          if(!idMapHas(pid)) return;
          partnerEdges.push({ data: { id: `e_partner_${rootId}_${pid}`, source: String(rootId), target: String(pid), rel: 'partner' } });
        });
        // parent pairs for children (ONE edge per unique pair)
        if(data.parentMap){
          for(const [, pars] of data.parentMap.entries()){
            if(!pars || pars.length < 2) continue;
            const p1 = String(pars[0]), p2 = String(pars[1]);
            if(!idMapHas(p1) || !idMapHas(p2)) continue;
            if(partnerEdgeExists(partnerEdges, p1, p2)) continue;
            partnerEdges.push({ data: { id: `e_pp_${[p1,p2].sort().join('_')}`, source: p1, target: p2, rel: 'partner' } });
          }
        }

        // ── Filter edges: remove sibling direct-edges and parent→child direct edges ─
        // (sibling connections are shown via shared junction; direct edges create crossing lines)
        let edgesCombined = (data.edges||[]).filter(e => {
          if(!e || !e.data) return false;
          const id = String(e.data.id || '');
          return !id.startsWith('e_sib_') && !id.startsWith('e_child_');
        }).concat(partnerEdges);

        // ── ONE junction node per unique parent pair, then junction→child edges ──
        const junctionNodes = [];
        const junctionEdges = [];
        if(data.parentMap){
          const pairJunctionMap = new Map(); // pairKey → junctionId
          for(const [childId, pars] of data.parentMap.entries()){
            if(!pars || pars.length < 2) continue;
            const p1 = String(pars[0]), p2 = String(pars[1]);
            if(!idMapHas(p1) || !idMapHas(p2) || !idMapHas(childId)) continue;
            const pairKey = [p1, p2].sort().join('__');
            if(!pairJunctionMap.has(pairKey)){
              const pos1 = positions.get(p1), pos2 = positions.get(p2);
              if(!pos1 || !pos2) continue;
              const jx = Math.round((pos1.x + pos2.x) / 2);
              const jy = Math.round((pos1.y + pos2.y) / 2);
              const junctionId = `junction_${pairKey}`;
              junctionNodes.push({ data: { id: junctionId, junctionFor: pairKey }, position: { x: jx, y: jy } });
              pairJunctionMap.set(pairKey, junctionId);
            }
            const junctionId = pairJunctionMap.get(pairKey);
            if(!junctionId) continue;
            const eId = `e_jc_${junctionId}_${childId}`;
            if(!junctionEdges.find(e => e.data.id === eId)){
              const childNode = (data.nodes||[]).find(n => String(n.data.id) === childId);
              const cg = (childNode && childNode.data && childNode.data.gender) ? String(childNode.data.gender).toLowerCase() : '';
              const cLabel = (cg==='female'||cg==='feminino'||cg==='f') ? 'Filha' : (cg==='male'||cg==='masculino'||cg==='m') ? 'Filho' : 'Filho(a)';
              junctionEdges.push({ data: { id: eId, source: junctionId, target: childId, label: cLabel } });
            }
          }
          // single-parent→child edges (when only one parent exists in parentMap)
          for(const [childId, pars] of data.parentMap.entries()){
            if(!pars || pars.length !== 1) continue;
            const p1 = String(pars[0]);
            if(!idMapHas(p1) || !idMapHas(childId)) continue;
            const eId = `e_sp_${p1}_${childId}`;
            if(!junctionEdges.find(e => e.data.id === eId) && !edgesCombined.find(e => e.data && e.data.id === eId)){
              const childNode = (data.nodes||[]).find(n => String(n.data.id) === childId);
              const cg = (childNode && childNode.data && childNode.data.gender) ? String(childNode.data.gender).toLowerCase() : '';
              const cLabel = (cg==='female'||cg==='feminino'||cg==='f') ? 'Filha' : (cg==='male'||cg==='masculino'||cg==='m') ? 'Filho' : 'Filho(a)';
              junctionEdges.push({ data: { id: eId, source: p1, target: childId, label: cLabel } });
            }
          }
          if(junctionNodes.length){ positionedNodes.push(...junctionNodes); }
          edgesCombined = edgesCombined.concat(junctionEdges);
        }

        const cyElements = { nodes: positionedNodes, edges: edgesCombined };

        _cy = cytoscape({
          container: container,
          elements: cyElements,
          style: [
            { selector: 'node', style: {
              'shape': 'round-rectangle', 'width': nodeWidth, 'height': nodeHeight,
              'background-image': 'data(img)', 'background-fit': 'cover',
              'background-width': '100%', 'background-height': '100%',
              'background-position-x': '50%', 'background-position-y': '50%',
              'border-width': 3, 'label': ''
            }},
            // junction dot: small visible circle
            { selector: 'node[junctionFor]', style: {
              'shape': 'ellipse', 'background-color': '#666', 'background-opacity': 1,
              'border-width': 0, 'width': 10, 'height': 10, 'label': ''
            }},
            { selector: 'node[gender]', style: { 'border-color': function(ele){
              const g = (ele.data('gender')||'').toString().toLowerCase();
              return (g==='female'||g==='feminino'||g==='f') ? '#e26aa6' : (g==='male'||g==='masculino'||g==='m') ? '#4a90e2' : '#9aa0a6';
            }}},
            // parent→child via junction: smooth bezier curves
            { selector: 'edge', style: {
              'width': 2, 'line-color': '#888',
              'target-arrow-shape': 'none',
              'curve-style': 'bezier',
              'control-point-step-size': 80,
              'label': ''
            }},
            // partner edges: straight dashed horizontal line, no arrows
            { selector: 'edge[rel = "partner"]', style: {
              'line-style': 'dashed',
              'curve-style': 'straight',
              'target-arrow-shape': 'none',
              'source-arrow-shape': 'none',
              'line-color': '#aaa',
              'label': ''
            }},
            { selector: 'edge.highlighted', style: {
              'line-color': '#4a90e2', 'target-arrow-color': '#4a90e2',
              'width': 4, 'opacity': 1, 'z-index': 9999
            }}
          ],
          layout: { name: 'preset' }
        });

        // disable selection so clicking a node doesn't trigger selection effects on other nodes
        try{ _cy.unselectify(); }catch(e){}

        // ── Keep junction nodes centred between their parent pair when dragged ──
        // Build map: personNodeId → [junctionId, ...]
        const _personToJunctions = new Map();
        _cy.nodes('[junctionFor]').forEach(function(jNode){
          const pairKey = jNode.data('junctionFor');
          if(!pairKey) return;
          pairKey.split('__').forEach(function(pid){
            if(!_personToJunctions.has(pid)) _personToJunctions.set(pid, []);
            _personToJunctions.get(pid).push(jNode.id());
          });
        });
        _cy.on('drag', 'node[name]', function(evt){
          const movedId = String(evt.target.id());
          const jIds = _personToJunctions.get(movedId) || [];
          jIds.forEach(function(jId){
            const jNode = _cy.getElementById(jId);
            if(!jNode || !jNode.length) return;
            const pairKey = jNode.data('junctionFor');
            if(!pairKey) return;
            const parts = pairKey.split('__');
            const n1 = _cy.getElementById(parts[0]), n2 = _cy.getElementById(parts[1]);
            if(!n1.length || !n2.length) return;
            const p1 = n1.position(), p2 = n2.position();
            jNode.position({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });
          });
        });

        // create DOM overlay buttons for nodes so icons are truly clickable
        let overlay = document.getElementById('cy-overlay');
        if(!overlay){
          overlay = document.createElement('div');
          overlay.id = 'cy-overlay';
          overlay.setAttribute('aria-hidden','true');
          container.appendChild(overlay);
        }
        // ensure overlay is correctly positioned; allow pointer events to pass through to Cytoscape
        overlay.style.position = 'absolute';
        overlay.style.inset = '0';
        overlay.style.zIndex = '1000';
        overlay.style.pointerEvents = 'none';
        function clearOverlay(){ if(overlay) overlay.innerHTML = ''; }
        function createOverlayButtons(){
          if(!overlay) return;
          clearOverlay();
          // set transform origin to top-left so model coords map correctly
          overlay.style.transformOrigin = '0 0';
          // initialize transform based on cy pan/zoom
          const p = _cy.pan(); const z = _cy.zoom(); overlay.style.transform = `translate(${p.x}px, ${p.y}px) scale(${z})`;
          (data.nodes || []).forEach(n => {
            const id = String(n.data.id);
            const node = _cy.getElementById(id);
            if(!node || node.empty()) return;
            const pos = node.position(); // model coordinates
            // button size in model units relative to nodeWidth/nodeHeight
            const btnSize = Math.max(18, Math.round(Math.min(nodeWidth, nodeHeight) * 0.18));
            const padding = Math.max(6, Math.round(btnSize * 0.4));

            const treeBtn = document.createElement('button');
            treeBtn.className = 'node-action tree';
            treeBtn.dataset.nodeId = id;
            treeBtn.title = 'Refazer árvore com esta pessoa em foco (temporário)';
            treeBtn.textContent = '🌳';
            treeBtn.style.position = 'absolute';
            treeBtn.style.left = (Math.round(pos.x + (nodeWidth/2) - padding - (btnSize * 2) - 8)) + 'px';
            treeBtn.style.top = (Math.round(pos.y + (nodeHeight/2) - padding - btnSize)) + 'px';
            treeBtn.style.width = btnSize + 'px';
            treeBtn.style.height = btnSize + 'px';
            treeBtn.style.borderRadius = (btnSize/2) + 'px';
            treeBtn.style.border = 'none';
            treeBtn.style.background = 'white';
            treeBtn.style.boxShadow = '0 1px 2px rgba(0,0,0,0.15)';
            treeBtn.style.pointerEvents = 'auto';
            treeBtn.style.zIndex = '1010';
            treeBtn.addEventListener('click', function(e){ e.stopPropagation(); window.RuntimeFocus = { id: id }; try{ renderGraph(); }catch(err){} });

            const eyeBtn = document.createElement('button');
            eyeBtn.className = 'node-action eye';
            eyeBtn.dataset.nodeId = id;
            eyeBtn.title = 'Ver detalhe desta pessoa';
            eyeBtn.textContent = '👁';
            eyeBtn.style.position = 'absolute';
            eyeBtn.style.left = (Math.round(pos.x + (nodeWidth/2) - padding - btnSize)) + 'px';
            eyeBtn.style.top = (Math.round(pos.y + (nodeHeight/2) - padding - btnSize)) + 'px';
            eyeBtn.style.width = btnSize + 'px';
            eyeBtn.style.height = btnSize + 'px';
            eyeBtn.style.borderRadius = (btnSize/2) + 'px';
            eyeBtn.style.border = 'none';
            eyeBtn.style.background = 'white';
            eyeBtn.style.boxShadow = '0 1px 2px rgba(0,0,0,0.15)';
            eyeBtn.style.pointerEvents = 'auto';
            eyeBtn.style.zIndex = '1010';
            eyeBtn.style.cursor = 'pointer';
            eyeBtn.style.background = 'rgba(68,147,248,0.92)';
            eyeBtn.style.color = '#fff';
            eyeBtn.style.fontSize = Math.max(11, btnSize * 0.55) + 'px';
            eyeBtn.textContent = '';
            const ei = document.createElement('i');
            ei.className = 'mdi mdi-pencil-outline';
            eyeBtn.textContent = '';
            eyeBtn.appendChild(ei);
            eyeBtn.addEventListener('click', function(e){ e.stopPropagation(); openDrawer('edit', id); });

            overlay.appendChild(treeBtn);
            overlay.appendChild(eyeBtn);
          });
        }

        function repositionOverlay(){ if(!overlay) return; // update overlay transform to track pan/zoom and reposition buttons
          const p = _cy.pan(); const z = _cy.zoom(); overlay.style.transform = `translate(${p.x}px, ${p.y}px) scale(${z})`;
          overlay.querySelectorAll('button.node-action').forEach(btn => {
            const id = btn.dataset.nodeId; const node = _cy.getElementById(id); if(!node || node.empty()){ btn.remove(); return; }
            const pos = node.position(); const btnSize = Math.max(18, Math.round(Math.min(nodeWidth, nodeHeight) * 0.18)); const padding = Math.max(6, Math.round(btnSize * 0.4));
            if(btn.classList.contains('tree')){
              btn.style.left = (Math.round(pos.x + (nodeWidth/2) - padding - (btnSize * 2) - 8)) + 'px';
              btn.style.top = (Math.round(pos.y + (nodeHeight/2) - padding - btnSize)) + 'px';
            } else {
              btn.style.left = (Math.round(pos.x + (nodeWidth/2) - padding - btnSize)) + 'px';
              btn.style.top = (Math.round(pos.y + (nodeHeight/2) - padding - btnSize)) + 'px';
            }
            btn.style.width = btnSize + 'px'; btn.style.height = btnSize + 'px'; btn.style.borderRadius = (btnSize/2) + 'px';
          }); }

        createOverlayButtons();
        _cy.on('pan zoom resize', function(){ repositionOverlay(); });

        // ignore node body taps now that overlay buttons handle actions
        _cy.on('tap', 'node', function(evt){});
        // toggle highlight class when an edge is tapped
        _cy.on('tap', 'edge', function(evt){ try{ const edge = evt.target; if(edge && typeof edge.toggleClass === 'function') edge.toggleClass('highlighted'); }catch(e){} });

        _cy.fit(40);
      }

      document.addEventListener('DOMContentLoaded', function(){
        renderGraph();
        // re-render on storage changes
        window.addEventListener('storage', function(){ try{ renderGraph(); }catch(e){} });
        const rankSel = document.getElementById('rankDir'); if(rankSel) rankSel.addEventListener('change', ()=>renderGraph());
        // reset focus button
        const resetBtn = document.getElementById('resetFocusBtn'); if(resetBtn) resetBtn.addEventListener('click', ()=>{ location.reload(); });
        // add person button opens drawer in create mode
        const addBtn = document.getElementById('addPersonTreeBtn'); if(addBtn) addBtn.addEventListener('click', ()=>openDrawer('create', null));
      });

      // ═════════════════════════════════════════════════════════════════
      //  DRAWER  — inline person editor
      // ═════════════════════════════════════════════════════════════════
      let _drawerPersonId = null;
      let _drawerMode = 'edit'; // 'edit' | 'create'

      function savePeople(arr){ localStorage.setItem('people:myLineage', JSON.stringify(arr)); }

      function openDrawer(mode, personId){
        // restore normal drawer state (in case coming back from section view)
        const _footer = document.querySelector('.drawer-footer');
        if(_footer) _footer.style.display = '';
        const _backBtn = document.getElementById('drawerBackBtn');
        if(_backBtn){ _backBtn.style.display = 'none'; _backBtn._personId = null; }
        const _phdr = document.getElementById('drawerPersonHeader');
        if(_phdr) _phdr.style.display = '';

        _drawerMode = mode;
        _drawerPersonId = personId ? String(personId) : null;
        const people = getPeople();
        const person = personId ? people.find(p=>String(p.id)===String(personId)) : null;
        const drawer  = document.getElementById('personDrawer');
        const overlay = document.getElementById('drawerOverlay');
        const title   = document.getElementById('drawerTitle');

        title.textContent = mode === 'create' ? 'Nova Pessoa' : 'Editar Pessoa';

        // populate identity strip
        const nameEl = document.getElementById('drawerPersonName');
        const subEl  = document.getElementById('drawerPersonSub');
        const avatarEl = document.getElementById('drawerAvatar');
        const detailLink = document.getElementById('drawerDetailLink');

        if(person){
          const fullName = (((person.firstName||'') + ' ' + (person.lastName||'')).trim()) || person.name || person.fullName || '(sem nome)';
          nameEl.textContent = fullName;
          // birth/death sub-line
          let sub = [];
          const ev = getEvents().find(e=>String(e.personId)===String(person.id) && e.type==='birth');
          if(ev && ev.date) sub.push('\u2605 ' + ev.date);
          const edeath = getEvents().find(e=>String(e.personId)===String(person.id) && e.type==='death');
          if(edeath && edeath.date) sub.push('\u271D ' + edeath.date);
          subEl.textContent = sub.join('  ·  ');
          const thumb = getThumbnailForPerson(person.id);
          if(thumb){
            avatarEl.style.backgroundImage = 'url(' + thumb + ')';
            avatarEl.style.backgroundSize = 'cover';
            avatarEl.style.backgroundPosition = 'center';
          } else {
            avatarEl.style.backgroundImage = '';
            const g = (person.gender||'').toLowerCase();
            avatarEl.style.background = (g==='female'||g==='feminino'||g==='f') ? '#e26aa6' : (g==='male'||g==='masculino'||g==='m') ? '#4493f8' : '#9aa0a6';
          }
          detailLink.href = 'pessoa-detalhe.html?id=' + encodeURIComponent(person.id);
          detailLink.style.display = '';
        } else {
          nameEl.textContent = 'Nova Pessoa';
          subEl.textContent = '';
          avatarEl.style.backgroundImage = '';
          avatarEl.style.background = 'var(--bg-surface-2)';
          detailLink.style.display = 'none';
        }

        // build form
        const body = document.getElementById('drawerBody');
        const firstName = person ? (person.firstName||'') : '';
        const lastName  = person ? (person.lastName||person.name||'')  : '';
        const gender    = person ? (person.gender||'') : '';
        const notes     = person ? (person.notes||person.bio||'') : '';
        body.innerHTML = [
          '<div class="drawer-section-label">Identidade</div>',
          '<div class="form-row">',
            '<div><label>Primeiro nome</label><input type="text" id="df_firstName" value="' + esc(firstName) + '" placeholder="Nome" /></div>',
            '<div><label>Apelido</label><input type="text" id="df_lastName" value="' + esc(lastName) + '" placeholder="Apelido" /></div>',
          '</div>',
          '<div><label>Género</label>',
            '<select id="df_gender">',
              '<option value=""' + (!gender?'selected':'') + '>(n/a)</option>',
              '<option value="male"' + (gender==='male'||gender==='masculino'||gender==='m'?'selected':'') + '>Masculino</option>',
              '<option value="female"' + (gender==='female'||gender==='feminino'||gender==='f'?'selected':'') + '>Feminino</option>',
            '</select></div>',
          '<div class="drawer-section-label" style="margin-top:8px;">Notas</div>',
          '<div><textarea id="df_notes" rows="3" placeholder="Notas...">' + esc(notes) + '</textarea></div>',
          person ? '<div style="margin-top:6px;display:flex;gap:10px;align-items:center;flex-wrap:wrap;"><button class="btn btn-ghost btn-sm" style="font-size:0.82rem;" onclick="openDrawerSection(\'' + person.id + '\', \'relacoes\')"><i class="mdi mdi-account-multiple-outline"></i> Relações</button><button class="btn btn-ghost btn-sm" style="font-size:0.82rem;" onclick="openDrawerSection(\'' + person.id + '\', \'eventos\')"><i class="mdi mdi-calendar-check-outline"></i> Eventos</button><button class="btn btn-ghost btn-sm" style="font-size:0.82rem;" onclick="openDrawerSection(\'' + person.id + '\', \'fotos\')"><i class="mdi mdi-image-multiple-outline"></i> Fotos</button></div>' : ''
        ].join('');

        drawer.classList.add('open');
        overlay.classList.add('open');
        // focus first input
        setTimeout(()=>{ const fi = document.getElementById('df_firstName'); if(fi) fi.focus(); }, 50);
      }

      function esc(s){ return String(s||'').replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;'); }

      function closeDrawer(){
        document.getElementById('personDrawer').classList.remove('open');
        document.getElementById('drawerOverlay').classList.remove('open');
      }

      // ── Section view (Relações / Eventos) inside the drawer ────────────
      let _drawerCurrentSection = null; // { personId, section }
      function openDrawerSection(personId, section){
        const people = getPeople();
        const person = people.find(p => String(p.id) === String(personId));
        if(!person) return;

        // hide edit footer & identity strip
        const footer = document.querySelector('.drawer-footer');
        if(footer) footer.style.display = 'none';
        const phdr = document.getElementById('drawerPersonHeader');
        if(phdr) phdr.style.display = 'none';

        // show back button and update title
        const backBtn = document.getElementById('drawerBackBtn');
        if(backBtn){
          backBtn.style.display = '';
          backBtn._personId = String(personId);
        }
        const sectionLabel = section === 'relacoes' ? 'Relações' : section === 'fotos' ? 'Fotos' : 'Eventos';
        const personName = (((person.firstName||'')+' '+(person.lastName||'')).trim()) || (person.name||'');
        document.getElementById('drawerTitle').textContent = sectionLabel + ' — ' + personName;

        _drawerCurrentSection = { personId: String(personId), section };
        // render content
        const body = document.getElementById('drawerBody');
        body.innerHTML = section === 'relacoes'
          ? _renderDrawerRelations(String(personId), people)
          : section === 'fotos'
          ? _renderDrawerPhotos(String(personId))
          : _renderDrawerEvents(String(personId));
      }

      function _esc(s){ return String(s||'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

      function _renderDrawerEvents(personId){
        const evs = getEvents().filter(ev => String(ev.personId) === personId && !ev.deletedAt);
        const typeLabels = { BIRTH:'Nascimento', BAPTISM:'Batismo', DEATH:'Óbito', MARRIAGE:'Casamento', DIVORCE:'Divórcio', ADOPTION:'Adoção', CUSTOM:'Outro' };
        function fmtDate(d){ if(!d) return ''; const parts = d.split(/[-T]/); return parts.length >= 3 ? parts[2]+'/'+parts[1]+'/'+parts[0] : d; }
        let html = `<div style="margin-bottom:12px;"><button class="btn btn-sm" onclick="_drawerShowAddEvent('${_esc(personId)}')" style="font-size:0.83rem;"><i class="mdi mdi-plus"></i> Adicionar Evento</button></div>`;
        if(!evs.length){ html += '<div style="color:#888;padding:4px 0 12px;">Nenhum evento cadastrado.</div>'; return html; }
        html += '<div class="mini-list">';
        evs.forEach(ev => {
          const label = typeLabels[(ev.type||'').toUpperCase()] || ev.type || '';
          html += `<div class="mini-card" style="padding:10px 12px;">`
            + `<div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">`
            + `<div style="flex:1;">`
            + `<span style="font-weight:600;font-size:0.9rem;">${_esc(label)}</span>`
            + `<span style="color:#888;font-size:0.82rem;margin-left:8px;">${_esc(fmtDate(ev.date||''))}</span>`
            + `</div>`
            + `<button onclick="_drawerDeleteEvent('${_esc(ev.id)}','${_esc(personId)}')" title="Apagar" style="background:none;border:none;cursor:pointer;color:#e06060;padding:2px 4px;font-size:1rem;line-height:1;flex-shrink:0;"><i class="mdi mdi-trash-can-outline"></i></button>`
            + `</div>`
            + (ev.location ? `<div style="color:#aaa;font-size:0.82rem;margin-top:3px;">&#128205; ${_esc(ev.location)}</div>` : '')
            + (ev.notes   ? `<div style="color:#bbb;font-size:0.82rem;margin-top:3px;">${_esc(ev.notes)}</div>` : '')
            + `</div>`;
        });
        html += '</div>';
        return html;
      }

      function _drawerDeleteEvent(eventId, personId){
        if(!confirm('Apagar este evento?')) return;
        let events = getEvents();
        events = events.map(ev => ev.id === eventId ? { ...ev, deletedAt: new Date().toISOString() } : ev);
        localStorage.setItem('events:myLineage', JSON.stringify(events));
        const body = document.getElementById('drawerBody');
        if(body) body.innerHTML = _renderDrawerEvents(personId);
      }

      function _renderDrawerRelations(personId, people){
        let relations = [];
        try{ relations = JSON.parse(localStorage.getItem('relations:myLineage')||'[]'); }catch(e){}
        const rels = relations.filter(r => r && String(r.from) === personId);
        const typeDesc = { siblin:'Irmão / Irmã', ancestor:'Pai / Mãe', child:'Filho(a)', mate:'Companheiro(a)' };
        let html = `<div style="margin-bottom:12px;"><button class="btn btn-sm" onclick="_drawerShowAddRelation('${_esc(personId)}')" style="font-size:0.83rem;"><i class="mdi mdi-plus"></i> Adicionar Relação</button></div>`;
        if(!rels.length){ html += '<div style="color:#888;padding:4px 0 12px;">Nenhuma relação cadastrada.</div>'; return html; }
        html += '<div class="mini-list">';
        rels.forEach(r => {
          const p = people.find(x => x.id === r.to);
          let desc = typeDesc[r.type] || r.type || '';
          if(p){
            const g = ((p.gender||'')+'').toLowerCase();
            const isFem = g==='female'||g==='feminino'||g==='f';
            const isMal = g==='male'||g==='masculino'||g==='m';
            if(desc.includes('Filho')) desc = isFem ? 'Filha' : isMal ? 'Filho' : 'Filho(a)';
            if(desc.includes('Pai')||desc.includes('Mãe')) desc = isFem ? 'Mãe' : isMal ? 'Pai' : 'Pai / Mãe';
            if(desc.toLowerCase().includes('compan')||desc.includes('mate')) desc = isFem ? 'Companheira' : isMal ? 'Companheiro' : 'Companheiro(a)';
            if(desc.includes('Irm')) desc = isFem ? 'Irmã' : isMal ? 'Irmão' : 'Irmão / Irmã';
          }
          const name = p ? (((p.firstName||'')+' '+(p.lastName||'')).trim()) : r.to;
          const toEsc = _esc(r.to);
          const typeEsc = _esc(r.type);
          html += `<div class="mini-card" style="padding:10px 12px;">`
            + `<div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">`
            + `<div style="flex:1;">`
            + `<span style="font-weight:600;font-size:0.9rem;">${_esc(name)}</span>`
            + `<span style="color:#aaa;font-size:0.82rem;margin-left:8px;">${_esc(desc)}</span>`
            + `</div>`
            + `<button onclick="_drawerDeleteRelation('${_esc(personId)}','${toEsc}','${typeEsc}')" title="Apagar" style="background:none;border:none;cursor:pointer;color:#e06060;padding:2px 4px;font-size:1rem;line-height:1;flex-shrink:0;"><i class="mdi mdi-trash-can-outline"></i></button>`
            + `</div>`
            + `</div>`;
        });
        html += '</div>';
        return html;
      }

      // ── Inline add-event form ──────────────────────────────────────────
      function _drawerShowAddEvent(personId){
        const body = document.getElementById('drawerBody');
        if(!body) return;
        body.innerHTML = `
          <div style="padding:4px 0 8px;">
            <h3 style="font-size:0.95rem;margin:0 0 14px;color:var(--text-primary);">Novo Evento</h3>
            <div class="form-group" style="margin-bottom:10px;">
              <label style="font-size:0.82rem;color:#aaa;display:block;margin-bottom:4px;">Tipo</label>
              <select id="addEvType" class="form-control" style="width:100%;">
                <option value="BIRTH">Nascimento</option>
                <option value="BAPTISM">Batismo</option>
                <option value="DEATH">Óbito</option>
                <option value="MARRIAGE">Casamento</option>
                <option value="DIVORCE">Divórcio</option>
                <option value="ADOPTION">Adoção</option>
                <option value="CUSTOM">Outro</option>
              </select>
            </div>
            <div class="form-group" style="margin-bottom:10px;">
              <label style="font-size:0.82rem;color:#aaa;display:block;margin-bottom:4px;">Data</label>
              <input id="addEvDate" type="date" class="form-control" style="width:100%;" />
            </div>
            <div class="form-group" style="margin-bottom:10px;">
              <label style="font-size:0.82rem;color:#aaa;display:block;margin-bottom:4px;">Local</label>
              <input id="addEvLocation" type="text" class="form-control" placeholder="Local do evento" style="width:100%;" />
            </div>
            <div class="form-group" style="margin-bottom:14px;">
              <label style="font-size:0.82rem;color:#aaa;display:block;margin-bottom:4px;">Notas</label>
              <textarea id="addEvNotes" class="form-control" rows="3" placeholder="Notas adicionais" style="width:100%;resize:vertical;"></textarea>
            </div>
            <div style="display:flex;gap:8px;justify-content:flex-end;">
              <button class="btn btn-ghost btn-sm" onclick="openDrawerSection('${_esc(personId)}','eventos')">Cancelar</button>
              <button class="btn btn-sm" onclick="_drawerSaveNewEvent('${_esc(personId)}')"><i class="mdi mdi-content-save-outline"></i> Guardar</button>
            </div>
          </div>`;
      }

      function _drawerSaveNewEvent(personId){
        const type     = (document.getElementById('addEvType')||{}).value || 'CUSTOM';
        const date     = (document.getElementById('addEvDate')||{}).value || '';
        const location = ((document.getElementById('addEvLocation')||{}).value || '').trim();
        const notes    = ((document.getElementById('addEvNotes')||{}).value || '').trim();
        let events = [];
        try{ events = JSON.parse(localStorage.getItem('events:myLineage')||'[]'); }catch(e){}
        const newEv = { id: 'ev_' + Date.now(), personId: String(personId), type: type.toUpperCase() };
        if(date)     newEv.date     = date;
        if(location) newEv.location = location;
        if(notes)    newEv.notes    = notes;
        events.push(newEv);
        localStorage.setItem('events:myLineage', JSON.stringify(events));
        openDrawerSection(personId, 'eventos');
      }

      // ── Inline add-relation form ──────────────────────────────────────────
      function _drawerShowAddRelation(personId){
        const people = getPeople().filter(p => !p.deletedAt && String(p.id) !== String(personId));
        const body = document.getElementById('drawerBody');
        if(!body) return;
        const opts = people.map(p => {
          const name = (((p.firstName||'')+' '+(p.lastName||'')).trim()) || p.name || p.id;
          return `<option value="${_esc(String(p.id))}">${_esc(name)}</option>`;
        }).join('');
        body.innerHTML = `
          <div style="padding:4px 0 8px;">
            <h3 style="font-size:0.95rem;margin:0 0 14px;color:var(--text-primary);">Nova Relação</h3>
            <div class="form-group" style="margin-bottom:10px;">
              <label style="font-size:0.82rem;color:#aaa;display:block;margin-bottom:4px;">Tipo de relação</label>
              <select id="addRelType" class="form-control" style="width:100%;">
                <option value="ancestor">Pai / Mãe</option>
                <option value="child">Filho(a)</option>
                <option value="mate">Companheiro(a)</option>
                <option value="siblin">Irmão / Irmã</option>
              </select>
            </div>
            <div class="form-group" style="margin-bottom:14px;">
              <label style="font-size:0.82rem;color:#aaa;display:block;margin-bottom:4px;">Pessoa</label>
              <select id="addRelTo" class="form-control" style="width:100%;">${opts||'<option disabled>Nenhuma pessoa disponível</option>'}</select>
            </div>
            <div style="display:flex;gap:8px;justify-content:flex-end;">
              <button class="btn btn-ghost btn-sm" onclick="openDrawerSection('${_esc(personId)}','relacoes')">Cancelar</button>
              <button class="btn btn-sm" onclick="_drawerSaveNewRelation('${_esc(personId)}')"><i class="mdi mdi-content-save-outline"></i> Guardar</button>
            </div>
          </div>`;
      }

      function _drawerSaveNewRelation(personId){
        const toId  = (document.getElementById('addRelTo')||{}).value || '';
        const type  = (document.getElementById('addRelType')||{}).value || 'mate';
        if(!toId){ alert('Seleciona uma pessoa.'); return; }
        let relations = [];
        try{ relations = JSON.parse(localStorage.getItem('relations:myLineage')||'[]'); }catch(e){}
        const already = relations.some(r => String(r.from)===String(personId) && String(r.to)===String(toId) && String(r.type)===String(type));
        if(already){ alert('Esta relação já existe.'); return; }
        relations.push({ from: String(personId), to: String(toId), type });
        localStorage.setItem('relations:myLineage', JSON.stringify(relations));
        openDrawerSection(personId, 'relacoes');
        renderGraph();
      }

      function _drawerDeleteRelation(fromId, toId, relType){
        if(!confirm('Apagar esta relação?')) return;
        let relations = [];
        try{ relations = JSON.parse(localStorage.getItem('relations:myLineage')||'[]'); }catch(e){}
        relations = relations.filter(r => !(String(r.from)===String(fromId) && String(r.to)===String(toId) && String(r.type)===String(relType)));
        localStorage.setItem('relations:myLineage', JSON.stringify(relations));
        const body = document.getElementById('drawerBody');
        if(body) body.innerHTML = _renderDrawerRelations(fromId, getPeople());
      }

      // ── Fotos section ─────────────────────────────────────────────────────
      function _renderDrawerPhotos(personId){
        const photos = getPhotos();
        const rels = getPhotoRelations();
        const linked = (rels[personId] || []).map(id => photos.find(p => String(p.id) === String(id))).filter(Boolean);
        let html = `<div style="margin-bottom:14px;">`
          + `<div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:6px;">`
          + `<label for="drawerPhotoInput" class="btn btn-sm" style="cursor:pointer;font-size:0.83rem;"><i class="mdi mdi-image-plus"></i> Escolher Ficheiro</label>`
          + `<span id="drawerPhotoName" style="color:#aaa;font-size:0.82rem;max-width:130px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">Nenhum ficheiro</span>`
          + `<button class="btn btn-sm" onclick="_drawerUploadPhoto('${_esc(personId)}')" style="font-size:0.83rem;"><i class="mdi mdi-upload"></i> Upload</button>`
          + `</div>`
          + `<input type="file" id="drawerPhotoInput" accept="image/*" style="display:none;" onchange="document.getElementById('drawerPhotoName').textContent=this.files&&this.files.length?this.files[0].name:'Nenhum ficheiro'" />`
          + `</div>`;
        if(!linked.length){ html += '<div style="color:#888;padding:4px 0 12px;">Nenhuma foto associada.</div>'; return html; }
        html += '<div style="display:flex;flex-wrap:wrap;gap:10px;">';
        linked.forEach(ph => {
          const src = ph.originalDataUrl || ph.dataUrl || '';
          html += `<div style="position:relative;display:inline-block;">`
            + `<img src="${src}" style="width:72px;height:72px;object-fit:cover;border-radius:6px;cursor:pointer;box-shadow:0 4px 12px rgba(0,0,0,0.3);" onclick="_drawerViewPhoto('${_esc(ph.id)}')" title="${_esc(ph.name||'')}" />`
            + `<button onclick="_drawerUnlinkPhoto('${_esc(ph.id)}','${_esc(personId)}')" title="Remover vínculo" style="position:absolute;top:-6px;right:-6px;background:#e06060;border:none;color:#fff;border-radius:50%;width:18px;height:18px;font-size:0.65rem;cursor:pointer;padding:0;display:flex;align-items:center;justify-content:center;"><i class="mdi mdi-close"></i></button>`
            + `</div>`;
        });
        html += '</div>';
        return html;
      }

      async function _drawerUploadPhoto(personId){
        const input = document.getElementById('drawerPhotoInput');
        if(!input || !input.files || !input.files.length) return alert('Selecione uma imagem para upload.');
        const photos = getPhotos();
        const rels = getPhotoRelations();
        const f = input.files[0];
        try{
          const dataUrl = await new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=()=>rej(); r.readAsDataURL(f); });
          const id = 'ph_' + Date.now();
          photos.push({ id, name: f.name, originalDataUrl: dataUrl, baseCopyName: null, createdAt: new Date().toISOString() });
          rels[personId] = rels[personId] || [];
          rels[personId].push(id);
          localStorage.setItem('photos:myLineage', JSON.stringify(photos));
          localStorage.setItem('photoRelations:myLineage', JSON.stringify(rels));
          input.value = '';
          openDrawerSection(personId, 'fotos');
        }catch(err){ alert('Erro no upload: ' + err); }
      }

      function _drawerUnlinkPhoto(photoId, personId){
        if(!confirm('Remover vínculo desta foto?')) return;
        const rels = getPhotoRelations();
        if(rels[personId]) rels[personId] = rels[personId].filter(id => String(id) !== String(photoId));
        localStorage.setItem('photoRelations:myLineage', JSON.stringify(rels));
        openDrawerSection(personId, 'fotos');
      }

      function _drawerViewPhoto(photoId){
        const ph = getPhotos().find(p => String(p.id) === String(photoId));
        if(!ph) return;
        const src = ph.originalDataUrl || ph.dataUrl || '';
        const lb = document.getElementById('drawerPhotoLightbox');
        const img = document.getElementById('drawerPhotoLightboxImg');
        if(lb && img){ img.src = src; lb.style.display = 'flex'; }
      }

      function drawerSave(){
        const firstName = (document.getElementById('df_firstName')||{}).value || '';
        const lastName  = (document.getElementById('df_lastName')||{}).value  || '';
        const gender    = (document.getElementById('df_gender')||{}).value    || '';
        const notes     = (document.getElementById('df_notes')||{}).value     || '';

        let people = getPeople();

        if(_drawerMode === 'create'){
          const newId = 'p_' + Date.now();
          const newPerson = { id: newId, firstName: firstName.trim(), lastName: lastName.trim(), gender, notes, createdAt: new Date().toISOString() };
          people.push(newPerson);
          savePeople(people);
          _drawerPersonId = newId;
        } else {
          const idx = people.findIndex(p=>String(p.id)===String(_drawerPersonId));
          if(idx !== -1){
            people[idx] = Object.assign({}, people[idx], { firstName: firstName.trim(), lastName: lastName.trim(), gender, notes, updatedAt: new Date().toISOString() });
            savePeople(people);
          }
        }

        closeDrawer();
        renderGraph();
      }

      function drawerSaveEvents(personId, birthDate, deathDate){
        let events = [];
        try{ events = JSON.parse(localStorage.getItem('events:myLineage')||'[]'); }catch(e){}
        // upsert birth
        if(birthDate){
          const bi = events.findIndex(e=>String(e.personId)===String(personId)&&e.type==='birth');
          if(bi !== -1){ events[bi] = Object.assign({}, events[bi], { date: birthDate }); }
          else{ events.push({ id: 'ev_' + Date.now() + '_b', personId: String(personId), type: 'birth', date: birthDate }); }
        }
        // upsert death
        if(deathDate){
          const di = events.findIndex(e=>String(e.personId)===String(personId)&&e.type==='death');
          if(di !== -1){ events[di] = Object.assign({}, events[di], { date: deathDate }); }
          else{ events.push({ id: 'ev_' + Date.now() + '_d', personId: String(personId), type: 'death', date: deathDate }); }
        }
        localStorage.setItem('events:myLineage', JSON.stringify(events));
      }

      function drawerDelete(){
        if(!_drawerPersonId) return;
        if(!confirm('Apagar esta pessoa? Esta ação não pode ser desfeita.')) return;
        let people = getPeople();
        const idx = people.findIndex(p=>String(p.id)===String(_drawerPersonId));
        if(idx !== -1){ people[idx] = Object.assign({}, people[idx], { deletedAt: new Date().toISOString() }); savePeople(people); }
        closeDrawer();
        renderGraph();
      }

      // wire drawer buttons (after DOM is ready)
      document.addEventListener('DOMContentLoaded', function(){
        document.getElementById('drawerCloseBtn').addEventListener('click', closeDrawer);
        document.getElementById('drawerCancelBtn').addEventListener('click', closeDrawer);
        document.getElementById('drawerOverlay').addEventListener('click', closeDrawer);
        document.getElementById('drawerSaveBtn').addEventListener('click', drawerSave);
        document.getElementById('drawerDeleteBtn').addEventListener('click', drawerDelete);
        document.getElementById('drawerBackBtn').addEventListener('click', function(){
          const pid = this._personId;
          if(pid) openDrawer('edit', pid);
        });
      });
    </script>
  </body>
</html>
