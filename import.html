<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Importar GEDCOM</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="app-shell">
      <aside class="sidebar">
        <div class="logo">XPTO</div>
        <nav>
          <a href="index.html">Cadastro</a>
          <a href="indicadores.html">Indicadores</a>
          <a href="pessoas.html">Pessoas</a>
          <a href="import.html" class="active">Importar</a>
          <a href="export.html">Exportar</a>
        </nav>
      </aside>
      <main class="content">
        <div class="topbar">
          <div><h1 style="margin:0;font-size:1.25rem;">Importar GEDCOM</h1></div>
          <div></div>
        </div>

        <div class="card" style="max-width:760px;">
          <p style="color:var(--text-secondary);margin-top:6px;">
            Aqui pode carregar um ficheiro GEDCOM (.ged). A importação irá substituir todos os dados atuais (Pessoas, Eventos e Relações) no armazenamento local. Faça um backup/export antes se quiser preservar os dados atuais.
          </p>

          <div style="display:flex;gap:12px;align-items:center;margin-top:12px;">
            <input type="file" id="gedcomFile" accept=".ged,text/plain" />
            <button class="btn" id="importBtn">Importar GEDCOM</button>
          </div>

          <div id="importLog" style="margin-top:16px;color:var(--text-secondary);font-size:0.95rem;white-space:pre-wrap;"></div>
        </div>

      </main>
    </div>

    <script>
      function nowISO(){ return new Date().toISOString(); }
      function showLog(msg){ document.getElementById('importLog').textContent = msg; }

      document.getElementById('importBtn').addEventListener('click', function(){
        const f = document.getElementById('gedcomFile').files[0];
        if(!f) return alert('Selecione um ficheiro GEDCOM (.ged)');
        if(!confirm('Confirma substituição de TODOS os dados existentes com os do ficheiro GEDCOM?')) return;
        const reader = new FileReader();
        reader.onload = function(e){
          try {
            const txt = e.target.result;
            const {people, events, relations} = parseGedcom(txt);
            // write to localStorage (overwrite)
            localStorage.setItem('people:xpto', JSON.stringify(people));
            localStorage.setItem('events:xpto', JSON.stringify(events));
            localStorage.setItem('relations:xpto', JSON.stringify(relations));
            showLog(`Import concluído. Pessoas: ${people.length}\nEventos: ${events.length}\nRelações: ${relations.length}`);
          } catch(err){
            console.error(err);
            showLog('Erro ao importar: ' + (err && err.message || err));
          }
        };
        reader.readAsText(f, 'utf-8');
      });

      // Basic GEDCOM parser: extracts INDI (individuals) and FAM (families) and common events (BIRT, DEAT)
      function parseGedcom(text){
        const lines = text.split(/\r?\n/).map(l => l.replace(/\t/g,' ').trimEnd());
        const records = [];
        let cur = null;
        for(const raw of lines){
          if(!raw) continue;
          const m = raw.match(/^(\d+)\s+(.*)$/);
          if(!m) continue;
          const level = parseInt(m[1],10);
          const rest = m[2];
          if(level === 0){
            if(cur) records.push(cur);
            cur = {raw:[rest], lines: [raw]};
          } else if(cur){
            cur.raw.push(rest);
            cur.lines.push(raw);
          }
        }
        if(cur) records.push(cur);

        const individuals = {};
        const families = {};

        for(const r of records){
          const first = r.raw[0];
          // INDIVIDUAL
          const indMatch = first.match(/^@([^@]+)@\s+INDI/);
          if(indMatch){
            const xref = indMatch[1];
            const obj = {id: xref, raw: r.raw.slice()};
            // parse lines inside
            let i=1;
            while(i<r.raw.length){
              const part = r.raw[i];
              if(part.startsWith('NAME')){
                const name = part.replace(/^NAME\s+/,'').trim();
                // GEDCOM name uses slashes for surname: Given /Surname/
                const surnameMatch = name.match(/\/(.*?)\//);
                obj.lastName = surnameMatch ? surnameMatch[1].trim() : '';
                obj.firstName = name.replace(/\/(.*?)\//,'').trim();
              } else if(part.startsWith('SEX')){
                const sex = part.replace(/^SEX\s+/,'').trim();
                obj.gender = (sex === 'M') ? 'male' : (sex === 'F') ? 'female' : 'other';
              } else if(part.startsWith('BIRT')){
                // next lines may include DATE
                if(r.raw[i+1] && r.raw[i+1].startsWith('DATE')){
                  obj.birth = r.raw[i+1].replace(/^DATE\s+/,'').trim();
                }
              } else if(part.startsWith('DEAT')){
                if(r.raw[i+1] && r.raw[i+1].startsWith('DATE')){
                  obj.death = r.raw[i+1].replace(/^DATE\s+/,'').trim();
                }
              }
              i++;
            }
            individuals[xref] = obj;
            continue;
          }
          // FAMILY
          const famMatch = first.match(/^@([^@]+)@\s+FAM/);
          if(famMatch){
            const xref = famMatch[1];
            const fam = {id: xref, raw: r.raw.slice(), HUSB: null, WIFE: null, CHIL: []};
            r.raw.forEach(line => {
              if(line.startsWith('HUSB')){
                const m = line.match(/@([^@]+)@/); if(m) fam.HUSB = m[1];
              } else if(line.startsWith('WIFE')){
                const m = line.match(/@([^@]+)@/); if(m) fam.WIFE = m[1];
              } else if(line.startsWith('CHIL')){
                const m = line.match(/@([^@]+)@/); if(m) fam.CHIL.push(m[1]);
              }
            });
            families[xref] = fam;
            continue;
          }
        }

        // Build people array
        const people = Object.values(individuals).map(ind => ({
          id: ind.id,
          firstName: ind.firstName || '',
          lastName: ind.lastName || '',
          gender: ind.gender || '',
          notes: '',
          createdAt: nowISO(),
          updatedAt: nowISO(),
          deletedAt: null
        }));

        // Build events
        const events = [];
        Object.values(individuals).forEach(ind => {
          if(ind.birth){ events.push({ id: ind.id + '_BIRT', personId: ind.id, type: 'BIRTH', date: ind.birth, location: null, notes: '', createdAt: nowISO(), updatedAt: nowISO(), deletedAt: null }); }
          if(ind.death){ events.push({ id: ind.id + '_DEAT', personId: ind.id, type: 'DEATH', date: ind.death, location: null, notes: '', createdAt: nowISO(), updatedAt: nowISO(), deletedAt: null }); }
        });

        // Build relations from families
        const relations = [];
        Object.values(families).forEach(fam => {
          if(fam.HUSB && fam.WIFE){
            relations.push({ from: fam.HUSB, to: fam.WIFE, type: 'mate' });
            relations.push({ from: fam.WIFE, to: fam.HUSB, type: 'mate' });
          }
          fam.CHIL.forEach(ch => {
            if(fam.HUSB) relations.push({ from: ch, to: fam.HUSB, type: 'ancestor' });
            if(fam.WIFE) relations.push({ from: ch, to: fam.WIFE, type: 'ancestor' });
            // sibling relations
            fam.CHIL.forEach(sib => { if(sib !== ch) relations.push({ from: ch, to: sib, type: 'siblin' }); });
          });
        });

        return { people, events, relations };
      }
    </script>
  </body>
</html>
