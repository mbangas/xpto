<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pessoas — Gráfico</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css">
    <!-- Cytoscape and dagre for hierarchical layout -->
    <script src="https://unpkg.com/cytoscape@3.24.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.3.2/cytoscape-dagre.js"></script>
    <style>
      /* small adjustments for Cytoscape container and node labels */
      #cy { background: #fafafa; border-radius:8px; }
      .cy-node-label { font-size:12px; font-weight:600; color:#222; }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <aside class="sidebar">
        <div class="logo"><i class="mdi mdi-tree" aria-hidden="true"></i><span>myLineage</span></div>
        <nav>
          <a href="index.html"><i class="mdi mdi-account-multiple" aria-hidden="true"></i>Cadastro</a>
          <a href="indicadores.html"><i class="mdi mdi-chart-bar" aria-hidden="true"></i>Indicadores</a>
          <a href="pessoas.html" class="active"><i class="mdi mdi-account" aria-hidden="true"></i>Pessoas</a>
          <a href="arvore.html"><i class="mdi mdi-sitemap" aria-hidden="true"></i>Árvore</a>
          <a href="import.html"><i class="mdi mdi-file-import" aria-hidden="true"></i>Importar</a>
          <a href="export.html"><i class="mdi mdi-file-export" aria-hidden="true"></i>Exportar</a>
        </nav>
        <div class="sidebar-footer">
          <a href="configuracao.html"><i class="mdi mdi-cog" aria-hidden="true"></i>Definições</a>
        </div>
      </aside>
      <main class="content">
        <div class="topbar">
          <div><h1 style="margin:0;font-size:1.25rem;">Visualização gráfica de Pessoas</h1></div>
          <div>
            <button id="toggleLayoutControls" class="btn lc-toggle" aria-pressed="false" aria-controls="layout-controls">Layout</button>
            <button id="resetFocusBtn" class="btn lc-toggle" title="Resetar pessoa em foco para a definida nas configurações">Reset foco</button>
          </div>
        </div>

        <div class="card">
          <div id="cy" style="width:100%;height:620px;"></div>
          <div class="legend" style="margin-top:12px;">
            <div><span class="avatar" style="background:#4a90e2"></span> Masculino</div>
            <div><span class="avatar" style="background:#e26aa6"></span> Feminino</div>
            <div><span class="avatar" style="background:#9aa0a6"></span> Outro</div>
          </div>
        </div>

        <div id="person-focus" class="person-focus" aria-live="polite"></div>

        <div id="layout-controls" class="layout-controls" aria-hidden="false">
          <div class="lc-header">Layout controls</div>
          <div class="lc-row"><label>Rank direction</label>
            <select id="rankDir"><option value="TB">Top &rarr; Down</option><option value="LR">Left &rarr; Right</option></select>
          </div>
          <div class="lc-row buttons"><button id="resetLayout" class="btn">Reset</button></div>
        </div>

      </main>
    </div>

    <script>
      // Helpers (localStorage-backed data)
      function getPeople(){ try{ const raw = localStorage.getItem('people:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function getPhotos(){ try{ const raw = localStorage.getItem('photos:myLineage'); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
      function getPhotoRelations(){ try{ const raw = localStorage.getItem('photoRelations:myLineage'); return raw ? JSON.parse(raw) : {}; }catch(e){ return {}; } }
      function genderPlaceholder(g){ const gender = (g||'').toString().toLowerCase(); const color = (gender==='female' || gender==='feminino' || gender==='f') ? '#e26aa6' : (gender==='male' || gender==='masculino' || gender==='m') ? '#4a90e2' : '#9aa0a6'; const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 120 120'><rect width='100%' height='100%' fill='${color}' rx='12'/></svg>`; return 'data:image/svg+xml;base64,' + btoa(svg); }
      function getThumbnailForPerson(personId){ try{ const rels = getPhotoRelations(); const photos = getPhotos(); const ids = rels[personId] || []; if(Array.isArray(ids) && ids.length){ for(const id of ids){ const ph = photos.find(p=>String(p.id)===String(id)); if(ph){ return ph.originalDataUrl || ph.dataUrl || null; } } } return null; }catch(e){ return null; } }

      // ensure RuntimeFocus exists on window for compatibility
      window.RuntimeFocus = window.RuntimeFocus || null;

      // Build a focused subgraph: focused person -> ancestors (upwards), siblings, partner(s), children
      function buildGraphData(){
        const people = getPeople().filter(p=>!p.deletedAt);
        const idMap = new Map(people.map(p=>[String(p.id), p]));
        // determine focus id: RuntimeFocus if set, otherwise persisted focus, otherwise first person
        function getFocusId(){
          if(window.RuntimeFocus && window.RuntimeFocus.id) return String(window.RuntimeFocus.id);
          try{
            const saved = JSON.parse(localStorage.getItem('focusedPerson:myLineage') || 'null');
            if(saved){ if(saved.id) return String(saved.id); if(saved.name){ const name = (saved.name||'').trim().toLowerCase(); const found = people.find(p => (((p.firstName||'') + ' ' + (p.lastName||'')).trim().toLowerCase() === name) || ((p.fullName||'') .toLowerCase() === name) || ((p.name||'').toLowerCase() === name)); if(found) return String(found.id); } }
          }catch(e){}
          return people.length ? String(people[0].id) : null;
        }

        const focusId = getFocusId(); if(!focusId) return { nodes: [], edges: [] };

        const nodesMap = new Map(); const edges = [];
        function addNode(p){ const id = String(p.id); if(!nodesMap.has(id)) nodesMap.set(id, { data: { id, name: (((p.firstName||'') + ' ' + (p.lastName||'')).trim()) || (p.name||''), img: getThumbnailForPerson(p.id) || genderPlaceholder(p.gender), gender: p.gender || '' } }); }

        // helper: collect parent ids from different possible keys used in data
        function getParentIds(person){ if(!person) return []; const ids = new Set(); const tryPush = v => { if(v===undefined || v===null) return; if(Array.isArray(v)){ v.forEach(x=>{ if(x!==undefined && x!==null) ids.add(String(x)); }); } else ids.add(String(v)); };
          tryPush(person.fatherId); tryPush(person.father); tryPush(person.paiId);
          tryPush(person.motherId); tryPush(person.mother); tryPush(person.maeId);
          if(Array.isArray(person.parents)) person.parents.forEach(x=>{ if(x!==undefined && x!==null) ids.add(String(x)); });
          return Array.from(ids);
        }

        // helper: check nested structures for presence of id (robust fallback)
        function containsId(value, id, seen){ if(value == null) return false; if(seen === undefined) seen = new Set(); if(typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return String(value) === String(id); if(Array.isArray(value)) return value.some(v => containsId(v, id, seen)); if(typeof value === 'object'){ if(seen.has(value)) return false; seen.add(value); return Object.values(value).some(v => containsId(v, id, seen)); } return false; }

        // add root
        const root = idMap.get(focusId);
        if(!root) return { nodes: [], edges: [] };
        addNode(root);

        // ancestors: recursively add parents (using all known parent keys)
        function addAncestors(person){ if(!person) return; const parents = getParentIds(person); parents.forEach(pid=>{ if(!pid) return; const parent = idMap.get(String(pid)); if(parent){ addNode(parent); const g = (parent.gender||'').toString().toLowerCase(); const label = g.startsWith('f') ? 'Mãe' : g.startsWith('m') ? 'Pai' : 'Pai / Mãe'; const edgeId = `e_${String(pid)}_${person.id}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: String(pid), target: String(person.id), label } }); addAncestors(parent); } }); }
        addAncestors(root);
        // fallback: if some parents are referenced in nested fields of root, pick them as well
        try{
          people.forEach(p=>{ if(!p || String(p.id) === String(root.id)) return; if(containsId(root, p.id) && !nodesMap.has(String(p.id))){ addNode(p); const g=(p.gender||'').toString().toLowerCase(); const label = g.startsWith('f') ? 'Mãe' : g.startsWith('m') ? 'Pai' : 'Pai / Mãe'; const edgeId = `e_${String(p.id)}_${root.id}`; if(!edges.find(e=>e.data && e.data.id===edgeId)) edges.push({ data:{ id: edgeId, source: String(p.id), target: String(root.id), label } }); addAncestors(p); } });
        }catch(e){}

        // siblings: people sharing any parent id with root (using all parent keys)
        function addSiblings(person){ if(!person) return; const myParents = new Set(getParentIds(person)); people.forEach(p=>{ const pid = String(p.id); if(pid === String(person.id)) return; const theirParents = getParentIds(p); const shares = theirParents.some(x => myParents.has(String(x))); if(shares){ addNode(p); const g = (p.gender||'').toString().toLowerCase(); const sibLabel = (g==='female' || g==='feminino' || g==='f') ? 'Irmã' : (g==='male' || g==='masculino' || g==='m') ? 'Irmão' : 'Irmão / Irmã'; const edgeId = `e_sib_${person.id}_${pid}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: String(person.id), target: pid, label: sibLabel } }); } }); }
        addSiblings(root);

        // partner(s): check spouseId / partnerId and relations store
        function addPartners(person){ if(!person) return; const partners = new Set(); if(person.spouseId) partners.add(String(person.spouseId)); if(person.partnerId) partners.add(String(person.partnerId)); // scan relations store for mate-like relations
          try{ const rels = JSON.parse(localStorage.getItem('relations:myLineage') || '[]'); rels.forEach(r=>{ if(!r) return; const from = String(r.from||r.personId||''); const to = String(r.to||r.targetId||''); const t = (r.type||'').toString().toLowerCase(); if((from === String(person.id) && (t.includes('mate')||t.includes('spouse')||t.includes('compan')||t.includes('parceiro')||t.includes('conjuge'))) && to) partners.add(to); if((to === String(person.id) && (t.includes('mate')||t.includes('spouse')||t.includes('compan')||t.includes('parceiro')||t.includes('conjuge'))) && from) partners.add(from); }); }catch(e){}
          partners.forEach(pid=>{ const p = idMap.get(pid); if(p){ addNode(p); const g = (p.gender||'').toString().toLowerCase(); const label = (g==='female'||g==='feminino'||g==='f') ? 'Companheira' : (g==='male'||g==='masculino'||g==='m') ? 'Companheiro' : 'Companheiro(a)'; edges.push({ data: { id: `e_partner_${person.id}_${pid}`, source: String(person.id), target: pid, label } }); } }); }
        addPartners(root);

        // children: people where root is listed as a parent in any supported key
        function addChildren(person){ if(!person) return; const rootId = String(person.id); people.forEach(p=>{ const pid = String(p.id); const parentIds = getParentIds(p); if(parentIds.includes(rootId) || containsId(p, rootId)){ addNode(p); const g=(p.gender||'').toString().toLowerCase(); const label = (g==='female'||g==='feminino'||g==='f') ? 'Filha' : (g==='male'||g==='masculino'||g==='m') ? 'Filho' : 'Filho(a)'; const edgeId = `e_child_${person.id}_${pid}`; if(!edges.find(e=>e.data && e.data.id === edgeId)) edges.push({ data: { id: edgeId, source: rootId, target: pid, label } }); } }); }
        addChildren(root);

        // produce arrays
        const nodes = Array.from(nodesMap.values());
        return { nodes, edges };
      }

      // Render with Cytoscape + dagre
      let _cy = null;
      function renderGraph(){
        const data = buildGraphData();
        const container = document.getElementById('cy');
        container.innerHTML = '';
        if(_cy){ try{ _cy.destroy(); }catch(e){} _cy = null; }

        _cy = cytoscape({
          container: container,
          elements: { nodes: data.nodes, edges: data.edges },
          style: [
            { selector: 'node', style: {
              'shape':'round-rectangle', 'width': 140, 'height': 140, 'background-fit':'cover', 'background-image':'data(img)', 'border-width':3,
              'label':'data(name)', 'text-valign':'bottom','text-wrap':'wrap','text-max-width':120,'font-size':12,'color':'#222','text-margin-y':6
            }},
            { selector: 'node[gender]', style: { 'border-color': function(ele){ const g = (ele.data('gender')||'').toString().toLowerCase(); return (g==='female'||g==='feminino'||g==='f') ? '#e26aa6' : (g==='male'||g==='masculino'||g==='m') ? '#4a90e2' : '#9aa0a6'; } }},
            { selector: 'edge', style: { 'width':2,'line-color':'#888','target-arrow-shape':'triangle','target-arrow-color':'#888','curve-style':'bezier' } }
          ],
          layout: { name: 'dagre', rankDir: (document.getElementById('rankDir')||{}).value || 'TB', nodeSep: 60, edgeSep: 10, rankSep: 100 }
        });

        _cy.on('tap', 'node', function(evt){ const id = evt.target.id(); window.location.href = `pessoa-detalhe.html?id=${encodeURIComponent(id)}`; });
        _cy.fit(30);
      }

      document.addEventListener('DOMContentLoaded', function(){
        renderGraph();
        // re-render on storage changes
        window.addEventListener('storage', function(){ try{ renderGraph(); }catch(e){} });
        // allow changing rank direction
        const rankSel = document.getElementById('rankDir'); if(rankSel) rankSel.addEventListener('change', ()=>renderGraph());
        // reset focus button
        const resetBtn = document.getElementById('resetFocusBtn'); if(resetBtn) resetBtn.addEventListener('click', ()=>{ location.reload(); });
      });
    </script>
  </body>
</html>
