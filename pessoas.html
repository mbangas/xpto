<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pessoas — Gráfico</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="app-shell">
      <aside class="sidebar">
        <div class="logo">XPTO</div>
        <nav>
          <a href="index.html">Cadastro</a>
          <a href="indicadores.html">Indicadores</a>
          <a href="pessoas.html" class="active">Pessoas</a>
          <a href="import.html">Importar</a>
          <a href="export.html">Exportar</a>
        </nav>
        <div class="sidebar-footer">
          <a href="configuracao.html">Configuração</a>
        </div>
      </aside>
      <main class="content">
        <div class="topbar">
          <div><h1 style="margin:0;font-size:1.25rem;">Visualização gráfica de Pessoas</h1></div>
          <div></div>
        </div>
        <div class="card">
          <svg id="graph" viewBox="0 0 1000 520" preserveAspectRatio="xMidYMid meet"></svg>
          <div class="legend" style="margin-top:12px;">
            <div><span class="avatar" style="background:#4a90e2"></span> Masculino</div>
            <div><span class="avatar" style="background:#e26aa6"></span> Feminino</div>
            <div><span class="avatar" style="background:#9aa0a6"></span> Outro</div>
          </div>
        </div>
        <div id="person-focus" class="person-focus" aria-live="polite"></div>
      </main>
    </div>
    <script>
      function getPeople() {
        try { const raw = localStorage.getItem('people:xpto'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; }
      }
      function getEvents() {
        try { const raw = localStorage.getItem('events:xpto'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; }
      }
      function formatDate(d){ if(!d) return ''; const t=new Date(d); if(isNaN(t)) return d; return t.getDate().toString().padStart(2,'0') + '-' + (t.getMonth()+1).toString().padStart(2,'0') + '-' + t.getFullYear(); }
      function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

      // Render only Miguel and direct relations in a simple family-tree layout
      function renderGraph(){
        const all = getPeople().filter(p => !p.deletedAt);
        const svg = document.getElementById('graph');
        svg.innerHTML = '';
        if(all.length === 0){
          const msg = document.createElementNS('http://www.w3.org/2000/svg','text');
          msg.setAttribute('x','50%'); msg.setAttribute('y','50%'); msg.setAttribute('text-anchor','middle'); msg.setAttribute('fill','#888'); msg.setAttribute('font-size','18'); msg.textContent = 'Nenhuma pessoa cadastrada.';
          svg.appendChild(msg); return;
        }

        // find Miguel by full name (normalized)
        function fullname(p){ return ((p.firstName||'') + ' ' + (p.lastName||'')).replace(/\s+/g,' ').trim(); }
        const targetName = 'Miguel Filipe do Amaral Bangueses';
        const root = all.find(p => fullname(p).toLowerCase() === targetName.toLowerCase());
        if(!root){
          const msg = document.createElementNS('http://www.w3.org/2000/svg','text');
          msg.setAttribute('x','50%'); msg.setAttribute('y','50%'); msg.setAttribute('text-anchor','middle'); msg.setAttribute('fill','#888'); msg.setAttribute('font-size','16'); msg.textContent = 'Pessoa "Miguel Filipe do Amaral Bangueses" não encontrada.';
          svg.appendChild(msg); return;
        }

        // helper: render person card into the central container
        function renderPersonCard(person){
          const focusEl = document.getElementById('person-focus');
          if(!person){ focusEl.innerHTML = ''; return; }
          const evs = getEvents().filter(ev=>ev.personId === person.id && !ev.deletedAt);
          const birth = evs.find(e=>e.type === 'BIRTH');
          const death = evs.find(e=>e.type === 'DEATH');
          const fullName = ((person.firstName||'') + ' ' + (person.lastName||'')).trim();
          const shortName = fullName.length > 36 ? fullName.slice(0,33) + '…' : fullName;
          focusEl.innerHTML = `
            <div class="person-card" role="article" aria-label="Pessoa em foco">
              <div class="person-name" title="${fullName}">${shortName}</div>
              <div class="person-dates" aria-hidden="false">
                <div class="person-date person-birth">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" stroke="currentColor" stroke-width="1.5"/><path d="M16 2V6M8 2V6M3 10H21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
                  <div class="date-text">${birth && birth.date ? formatDate(birth.date) : ''}</div>
                </div>
                <div class="person-date person-death">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 2v7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M7 11c0 3 2 5 5 5s5-2 5-5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M5 20h14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
                  <div class="date-text">${death && death.date ? formatDate(death.date) : ''}</div>
                </div>
              </div>
            </div>
            <div class="relations-container" aria-hidden="false"></div>
          `;

          // render related person cards around the focus card using relations stored in localStorage ('relations:xpto')
          const relWrap = focusEl.querySelector('.relations-container');
          function getRelationsStore(){ try { const raw = localStorage.getItem('relations:xpto'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; } }
          const typeDesc = { siblin: 'Irmão / Irmã', ancestor: 'Pai / Mãe', child: 'Filho(a)', mate: 'Companheiro(a)' };
          if(relWrap){
            relWrap.innerHTML = '';
            const relations = getRelationsStore();
            // relations where focused person is the origin
            const relsFrom = relations.filter(r => String(r.from) === String(person.id));
            // if none, fallback to relations where focused person is the target (show the origin persons)
            const targets = [];
            if(relsFrom.length > 0){
              relsFrom.forEach(r => { if(r && r.to) targets.push({ id: r.to, type: r.type }); });
            } else {
              const relsTo = relations.filter(r => String(r.to) === String(person.id));
              relsTo.forEach(r => { if(r && r.from) targets.push({ id: r.from, type: r.type }); });
            }

            // unique by id
            const unique = Array.from(new Map(targets.map(t => [String(t.id), t])).values());

            unique.forEach((t, i) => {
              const related = all.find(x => String(x.id) === String(t.id));
              if(!related) return;
              const name = (((related.firstName||'') + ' ' + (related.lastName||'')).trim()) || (related.name||related.fullName||related.displayName||'');
              const short = name.length > 20 ? name.slice(0,17) + '…' : name;
              const relLabel = typeDesc[t.type] || t.type || '';
              const card = document.createElement('div');
              card.className = 'relation-card';
              card.setAttribute('role','button');
              card.setAttribute('tabindex','0');
              card.innerHTML = `<div class="relation-name" title="${name}">${short}</div><div class="relation-type">${escapeHtml(relLabel)}</div>`;
              // position around in a circle
              const n = unique.length || 1; const angle = (i / n) * Math.PI * 2; const radius = 190;
              const dx = Math.round(Math.cos(angle) * radius); const dy = Math.round(Math.sin(angle) * radius);
              card.style.transform = `translate(${dx}px, ${dy}px)`;
              card.addEventListener('click', ()=>{ renderPersonCard(related); });
              card.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'||e.key===' ') renderPersonCard(related); });
              relWrap.appendChild(card);
            });
          }
        }

        // read configured focused person from settings and render automatically if present
        try {
          const FOCUS_KEY = 'focusedPerson:xpto';
          const saved = JSON.parse(localStorage.getItem(FOCUS_KEY) || 'null');
          if(saved && saved.name){
            const targetName = (saved.name || '').trim().toLowerCase();
            const person = all.find(p => (((p.firstName||'') + ' ' + (p.lastName||'')).replace(/\s+/g,' ').trim().toLowerCase() === targetName) || ((p.fullName||'') .toLowerCase() === targetName) || ((p.name||'').toLowerCase() === targetName));
            if(person) renderPersonCard(person);
          }
        } catch(e){ console.warn('Erro ao carregar pessoa em foco das configurações:', e); }

        // detect direct relations
        const nodes = {};
        const edges = [];

        function addNode(p){ if(!nodes[p.id]) nodes[p.id] = p; }
        addNode(root);

        // broaden relation detection: check any field / array / nested object that references the root id
        function containsId(value, id, seen){
          if(value == null) return false;
          if(seen === undefined) seen = new Set();
          if(typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return value == id;
          if(Array.isArray(value)) return value.some(v => containsId(v, id, seen));
          if(typeof value === 'object'){
            if(seen.has(value)) return false; seen.add(value);
            return Object.values(value).some(v => containsId(v, id, seen));
          }
          return false;
        }

        function detectLabelByKey(p, id){
          // try to infer relation label by common key names
          if(p.fatherId == id || p.father == id || p.paiId == id) return 'Pai';
          if(p.motherId == id || p.mother == id || p.maeId == id) return 'Mãe';
          if(p.spouseId == id || p.partnerId == id || p.conjugeId == id) return 'Cônjuge';
          if(Array.isArray(p.parents) && p.parents.includes(id)) return 'Pai/Mãe';
          return null;
        }

        all.forEach(p => {
          if(p.id === root.id) return;
          let rel = null;

          // direct known keys
          rel = detectLabelByKey(p, root.id) || detectLabelByKey(root, p.id);

          // if any nested field in p references root.id
          if(!rel && containsId(p, root.id)) rel = 'Parente';

          // if root references p
          if(!rel && containsId(root, p.id)) rel = 'Relacionado';

          // special: relations array with typed relations
          if(!rel && Array.isArray(p.relations)){
            for(const r of p.relations){
              if(r == null) continue;
              if(r.personId == root.id || r.to == root.id || r.targetId == root.id){ rel = r.type || r.label || 'Parente'; break; }
              if(r.personId == p.id && (r.to == root.id || r.targetId == root.id)) { rel = r.type || r.label || 'Parente'; break; }
            }
          }

          if(rel){ addNode(p); edges.push({from: root.id, to: p.id, label: rel}); }
        });

        // Basic layout: root at top-center, parents above, spouses to right, children below, others left
        const w = 1000, h = 520;
        const positions = {};
        positions[root.id] = {x: w/2, y: 80};

        const parents = [], spouses = [], children = [], others = [];
        Object.values(nodes).forEach(p => { if(p.id === root.id) return; });
        edges.forEach(e=>{
          const p = nodes[e.to];
          if(!p) return;
          const label = (e.label||'').toLowerCase();
          if(label.includes('pai') || label.includes('mãe') || label.includes('pai/mãe')) parents.push(p);
          else if(label.includes('côn') || label.includes('cônjuge') || label.includes('parceiro')) spouses.push(p);
          else if(label.includes('filho')) children.push(p);
          else others.push(p);
        });

        function placeRow(arr, y, startX, spacing){
          const total = arr.length; const base = startX - ((total-1) * spacing)/2;
          arr.forEach((p,i)=> positions[p.id] = {x: base + i*spacing, y: y});
        }

        if(parents.length) placeRow(parents, 20, w/2, 160);
        if(spouses.length) placeRow(spouses, 100, (w/2)+220, 120);
        if(children.length) placeRow(children, 260, w/2, 160);
        if(others.length) placeRow(others, 180, (w/2)-260, 140);

        // draw edges
        function drawLine(x1,y1,x2,y2, label){
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2);
          line.setAttribute('stroke', '#777'); line.setAttribute('stroke-width', '2'); svg.appendChild(line);
          if(label){
            const mx = (x1+x2)/2; const my = (y1+y2)/2;
            const lab = document.createElementNS('http://www.w3.org/2000/svg','text');
            lab.setAttribute('x', mx); lab.setAttribute('y', my - 8); lab.setAttribute('text-anchor','middle'); lab.setAttribute('fill','#444'); lab.setAttribute('font-size','12'); lab.textContent = label;
            svg.appendChild(lab);
          }
        }

        // draw nodes
        Object.values(nodes).forEach(p=>{
          const pos = positions[p.id] || {x: w/2, y: 120};
          // Invisible clickable area for the node (no visible circle or initials)
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx', pos.x); c.setAttribute('cy', pos.y); c.setAttribute('r', 30);
          c.setAttribute('fill', 'transparent'); c.setAttribute('stroke', 'transparent');
          c.setAttribute('style', 'cursor:pointer');
          c.addEventListener('click', ()=>{ renderPersonCard(p); });
          svg.appendChild(c);
        });

        // draw relation lines afterwards
        edges.forEach(e=>{
          const from = positions[e.from]; const to = positions[e.to];
          if(!from || !to) return;
          drawLine(from.x, from.y, to.x, to.y, e.label);
        });
      }

      window.addEventListener('storage', renderGraph);
      document.addEventListener('DOMContentLoaded', renderGraph);
    </script>
  </body>
</html>
